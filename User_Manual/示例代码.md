# 示例代码

## 1.读取txt文本文件

### 1.1 函数名: `read_txt`

#### 使用方法

**描述 **:  一次性读取文本文件内容,适合小文件

**参数**:  `file_path:<&str>` : 文件路径

**返回值**:  

成功：`Result<String>` : 返回字符串,字符串包含整个txt文件的内容

失败： 文件路径不存在， 文件类型错误，无法打开文件

  ```rust
use FileContentReader::FileReader;
let res = 												 FileReader::read_txt("src/test_examples/test_txt.txt");
match res {
    Ok(content) => println!("文本文件内容: \n {}", content),
    Err(e) => println!("读取文本文件失败: {}", e), 
}
  ```
#### 集成流程

输入文件路径，创建缓冲读取器，将文件内容读取到字符串中，并将文件内容返回



### 1.2 函数名: `read_txt_by_line`

#### 使用方法

**描述**:  按行读取txt文本文件内容

**参数：**`file_path:AsRef<Path>`:文件路径

**返回值**:  

成功：`Result<Vec<String>>` : 返回一个字符串可变数组,一个字符串一个内容

失败：文件路径错误，文件类型错误，无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_txt_by_line("src/test_examples/test_txt.txt");
match res {
	Ok(content) => println!("文本文件内容: \n {:?}",content),
	Err(e) => println!("读取文本文件失败: {}", e), 
}

 ```

#### 集成流程

输入文件路径，创建缓冲区，无限循环，按行读取文件内容，每一行内容作为一个字符串，返回字符串向量



### 1.3 函数名: `read_txt_by_byte`

#### 使用方法

**描述**:  按字节读取txt文本文件内容

**参数**:  `file_path:AsRef<Path>` : 文件路径

**返回值**: 

成功： `Result<Vec<u8>>` : 返回一个u8字节数组，数组包含文本内容

失败：文件路径错误， 文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_txt_by_byte("src/test_examples/test_txt.txt");
match res {
    Ok(content) => println!("文本文件内容: \n {:?}", content),
    Err(e) => println!("读取文本文件失败: {}", e), 
}
 ```

#### 集成流程

输入文件路径，创建缓冲区和缓冲字节数组，按字节读取文件内容，返回字节向量



### 1.4函数名: `read_txt_by_block`

#### 使用方法

**描述**:  按块读取txt文件

**参数**:  
	`file_path:<&str>` : 文件路径
	`block_size:<usize>` : 每次读取的块大小，以字节为单位

**返回值**: 

 成功：`Result<Vec<String>>` : 返回一个包含每个块的向量，每个块都是一个字符串

 失败： 文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_txt_by_block("src/test_examples/test_txt.txt",4);
match res {
	Ok(content) => println!("文本文件内容: \n {:?}", content),
	Err(e) => println!("读取文本文件失败: {}", e), 
}
 ```

#### 集成流程

输入文件路径，文件块大小，按块读取文件内容，将读取的每个块分别转换为字符串，返回字符串向量



## 2.读取csv文件

### 2.1函数名: `read_csv_by_line`

#### 使用方法

**描述**:  按行读取csv文件,默认不读取列名

**参数**:  `file_path:<&str>` : 文件路径

**返回值**:  

成功：`Result<Vec<Vec<String>>>` : 返回一个二维String数组，一个字符串为一个数据

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_csv_by_line("src/test_examples/test_csv.csv");
match res {
	Ok(content) => println!("csv文件内容: \n {:?}", content),
	Err(e) => println!("读取csv文件失败: {}", e), 
}
 ```
#### 集成流程

输入文件路径，构建 Reader 实例的构造器，允许用户配置 Reader 的行为，创建一个 CSV 读取器。遍历csv文件每一行内容，一行内容的一个数据读取为字符串，文件的一行内容就是一个字符串向量，然后再将每行的内容添加到另一个向量中，最后按行返回csv文件内容



### 2.2函数名: `read_csv_by_column`

#### 使用方法

**描述**:  按列读取csv文件

**参数**:  `file_path:<&str>` : 文件路径

**返回值**:  

成功：`Result<Vec<Vec<String>>>` : 返回一个二维String数组，一个字符串为一个数据

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_csv_by_column("src/test_examples/test_csv.csv");
match res {
	Ok(content) => println!("csv文件内容: \n {:?}", content),
	Err(e) => println!("读取csv文件失败: {}", e), 
}
 ```

#### 集成流程

输入文件路径，构建Reader 实例的构造器，允许用户配置 Reader 的行为，创建一个 CSV 读取器。按行读取csv文件内容，然后将按行读取到的csv文件内容转换成按列读取的csv文件内容，最后返回按列读取的csv文件内容。每一列文件内容就是一个字符串向量，整个文件内容就是一个向量，里面每一个元素就是一个字符串向量



### 2.3函数名: `read_csv_by_block`

#### 使用方法

**描述**:  按块读取csv文件

**参数**:  
	`file_path:<&str>` : 文件路径
	`block_size:<usize>` : 每次读取的块大小，以字节为单位

**返回值**: 

成功： `Result<Vec<Vec<Vec<String>>>` : 返回一个向量，每个向量元素即为csv文件块的内容，用二维向量存储

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_csv_by_block("src/test_examples/test_csv.csv",4);
match res {
	Ok(content) => println!("csv文件内容: \n {:?}", content),
	Err(e) => println!("读取csv文件失败: {}", e), 
}
 ```

#### 集成流程

输入文件路径，块的大小即文件内容行数，构建 Reader 实例的构造器，创建一个 CSV 读取器。按块读取csv文件内容，最后将剩余的文件内容，添加到。每一个块由多行内容组成，数据结构为 `Vec<Vec<String>>`，整个文件由多个块组成



## 3.读取json文件

### 3.1函数名: `read_json_text`

#### 使用方法

**描述**:  读取json文件内容

**参数**:  `file_path:<&str>` : 文件路径

**返回值**:  

成功：`Result<String>` : 返回字符串,字符串包含整个json文件的内容

失败： 文件路径错误，文件类型错误， 无法打开文件 

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_json_text("src/test_examples/test_json.json");
match res {
	Ok(content) => println!("json文件内容: \n {}", content),
	Err(e) => println!("读取json文件失败: {}", e), 
}
 ```

#### 集成流程

调用文件读取库中的读取TXT文件内容的方法，一次性将json文件读取到字符串中并返回



### 3.2函数名: `read_json_dynamic`

#### 使用方法

**描述**:  动态读取json文件

**参数**:  `file_path:<&str>` : 文件路径

**返回值**: 

成功： `serde_json::Result<Value>` : 返回Value，Value包含整个json文件的内容

失败： 文件路径错误，文件类型错误， 无法打开文件 

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_json_dynamic("src/test_examples/test_json.json");
match res {
	Ok(content) => println!("json文件内容: \n {}", content),
	Err(e) => println!("读取json文件失败: {}", e), 
}
 ```

#### 集成流程

输入文件路径打开文件，创建缓冲区，使用`serde_json::from_reader`方法从缓冲器中直接解析 JSON 数据，最后返回json文件内容



### 3.3函数名: `read_jsonl_by_line`

#### 使用方法

**描述**:  按行读取jsonl文件

**参数**:  `file_path:<&str>` : 文件路径

**返回值**:  

成功：`Result<Vec<Value>>` : 返回Value数组，Value数组包含整个jsonl文件的内容

失败： 文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_jsonl_by_line("src/test_examples/test_jsonline.jsonl");
match res {
    Ok(content) => println!("jsonline文件内容: \n {:?}", content),
    Err(e) => println!("读取jsonline文件失败: {}", e), 
}
 ```

#### 集成流程

输入json文件路径，打开文件，创建缓冲区，遍历json文件每一行内容，使用`from_str`函数解析每一行字符串，返回`serde_json::Value`类型数据。每一行数据就是一个`Value`,最终返回类型为`Value`的向量



### 3.4函数名: `read_json_by_block`

#### 使用方法

**描述**:  按块读取json文件

**参数**:
	`file_path:<&str>` : 文件路径
	`block_size:<usize>` : 每次读取的块大小，以对象的数量为单位

**返回值**:  

成功：`Result<Vec<Vec<Value>>>` : 返回包含每个块的向量，每个块都是一个对象向量

失败： 文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_json_by_block("src/test_examples/test_json.json",4);
match res {
	Ok(content) => println!("json文件内容: \n {:?}", content),
	Err(e) => println!("读取json文件失败: {}", e), 
}
 ```
#### 集成流程

输入文件路径和块的大小，尝试打开指定文件路径，创建缓冲读取器，读取文件内容到字符串，反序列化整个JSON文件，同时检查JSON文件内容是否为数组，如果是数组则按块分割，分割之后每个块是元素为`Value`的向量，最后判断最后一个块是否符合要求，如果不符合仍然保存。这里的块大小其实就是就是json字典的数量。



## 4.读取xml文件

### 4.1函数名: `read_xml_text`

#### 使用方法

**描述**:  读取xml文件内容

**参数**:  `file_path:<&str>` : 文件路径

**返回值**:  

成功：`Result<String>` : 返回字符串,字符串包含整个xml文件的内容

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_xml_text("src/test_examples/test_xml.xml");
match res {
	Ok(content) => println!("xml文件内容: \n {}", content),
	Err(e) => println!("读取xml文件失败: {}", e), 
}
 ```

#### 集成流程

输入文件路径，调用文件内容读取库中`read_txt`方法，直接读取XML文件内容，以字符串的形式返回



### 4.2函数名: `read_xml_by_listener`

#### 使用方法

**描述**:  读取xml文件内容

**参数**:
	`file_path:<&str>` : 文件路径
	`on_start:<FnMut(&str)>` : 处理start事件的函数
	`on_text:<FnMut(&str)>` :  处理text事件的函数
	`on_end:<FnMut(&str)>` :  处理end事件的函数

**返回值**:  

成功：`Result<()>` : 无返回值

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
// 读取xml文件标签
let mut start_tags:Vec<String> = Vec::new();
let mut end_tags:Vec<String> = Vec::new();
let mut text:Vec<String> = Vec::new();
 // 处理标签的闭包
let on_start = |tag_name:&str|{
      start_tags.push(tag_name.to_string());
};
let on_end = |tag_name:&str| {
    end_tags.push(tag_name.to_string());
};
let on_text = |text_content:&str| {
    text.push(text_content.to_string());
};
let res = FileReader::read_xml_by_listener("src/test_examples/test_xml.xml", on_start, on_text, on_end);
match res {
    Ok(()) => {
        println!("Start tags:");
        for start in start_tags {
            println!("  {}", start);
        }

        println!("Text nodes:");
        for text in text {
            println!("  {}", text);
        }

        println!("end tags:");
        for end in end_tags {
            println!("  {}", end);
        }
    },
    Err(e) => eprintln!("Error processing XML: {}", e),
}
 ```

####  集成流程

输入文件路径，三个泛型参数分别代表开始标签、文本节点和结束标签的处理函数。打开文件，创建缓冲读取器，`quick_xml::Reader::from_reader(reader)`创建 XML 读取器，去除空白字符，根据传入的处理函数对XML事件进行解析，返回结果。



## 5.读取markdown文件

### 5.1函数名: `read_markdown`

#### 使用方法

**描述**:  读取Markdown文件内容

**参数**:  `file_path:<&str>` : Markdown文件路径

**返回值**:  

成功：`Result<String>`:返回Markdown文件内容的字符串

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_markdown("src/test_examples/test_md.md");
match res {
    Ok(content) => println!("md文件内容: \n {}", content),
    Err(e) => println!("读取md文件失败: {}", e), 
}
 ```
#### 集成流程

输入文件路径，打开文件，创建缓冲读取器，读取文件内容到字符串，返回结果



### 5.2函数名: `read_md_by_line`

#### 使用方法

**描述**:  按行读取markdown文件

**参数**:  `file_path:<&str>` : markdown文件路径

**返回值**:  

成功：`Result<Vec<String>>` : 返回markdown文件内容的字符串数组

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_md_by_line("src/test_examples/test_md.md");
match res {
    Ok(content) => println!("md文件内容: \n {:?}", content),
    Err(e) => println!("读取md文件失败: {}", e), 
}
 ```

#### 集成流程

输入文件路径，创建缓冲区，无限循环，按行读取文件内容，每一行内容作为一个字符串，返回字符串向量



### 5.3函数名: `read_md_by_byte`

#### 使用方法

**描述**:  按字节读取markdown文件

**参数**:  `file_path:<&str>`: markdown文件路径

**返回值**:  

成功：`Result<Vec<u8>>`:返回markdown文件内容的u8字节数组

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_md_by_byte("src/test_examples/test_md.md");
match res {
    Ok(content) => println!("md文件内容: \n {:?}", content),
    Err(e) => println!("读取md文件失败: {}", e), 
}
 ```

#### 集成流程

输入文件路径，创建缓冲区和缓冲字节数组，按字节读取文件内容，返回字节向量



### 5.4函数名: `read_md_by_block`

#### 使用方法

**描述**:  按块读取markdown文件

**参数**:
	`file_path:<&str>` : markdown文件路径
	`block_size:<usize>` : 每次读取的块大小，以字节为单位

**返回值**:  

成功：`Result<Vec<String>>` : 返回markdown文件内容的字符串数组

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_md_by_block("src/test_examples/test_md.md",4);
match res {
    Ok(content) => println!("md文件内容: \n {:?}", content),
    Err(e) => println!("读取md文件失败: {}", e), 
}
 ```

#### 集成流程

输入文件路径，文件块大小，按块读取文件内容，将读取的每个块分别转换为字符串，返回字符串向量



### 5.5函数名: `read_markdown_and_convert_to_html`

#### 使用方法

**描述**:  读取markdown文件并转换为HTML

**参数**:  `file_path:<&str>` : Markdown文件路径

**返回值**:  

成功：`Result<String>` : 返回转换后的HTML内容

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_markdown_and_convert_to_html("src/test_examples/test_md.md");
match res {
    Ok(content) => println!("md文件内容: \n {}", content),
    Err(e) => println!("读取md文件失败: {}", e), 
}
 ```
#### 集成流程

输入Markdown文件路径，使用 `Self::read_markdown(file_path).unwrap()` 来读取 Markdown 文件内容，使用 `Parser::new` 创建解析器，并将 Markdown 内容解析为 HTML，使用 `html::push_html` 方法将解析后的 HTML 内容推送到字符串中，返回一个包含转换后的 HTML 内容的字符串



## 6.读取PDF文件

### 6.1函数名: `read_pdf_as_string`

#### 使用方法

**描述**:  读取PDF文件内容

**参数**:  `file_path:<&str>` : pdf文件路径

**返回值**:  

成功：`Result<String>` : 返回pdf所有页内容的字符串

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_pdf_as_string("src/test_examples/test_pdf.pdf");
match res {
	Ok(content) => println!("pdf文件内容: \n {}", content),
	Err(e) => println!("读取pdf文件失败: {}", e), 
}
 ```

#### 集成流程

输入文件路径，调用函数来提取PDF文件中的文本内容，返回字符串结果



## 7.读取excel文件

### 7.1函数名: `read_excel_as_string`

#### 使用方法

**描述**:  读取excel文件中的所有内容，并以字符串形式返回

**参数**:  `file_path:<&str>` : excel文件路径

**返回值**:  

成功：`Result<String>` : 成功时返回包含excel内容的字符串，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_excel_as_string("src/test_examples/test_excel.xlsx");
match res {
    Ok(content) => println!("excel文件内容: \n {}", content),
    Err(e) => println!("读取excel文件失败: {}", e), 
}
 ```

#### 集成流程

输入excel文件路径，使用 `open_workbook_auto` 函数打开 Excel 文件，通过 `workbook.sheet_names()` 获取所有工作表的名称，并遍历每个工作表，通过 `worksheet_range` 方法获取工作表的范围，并遍历每一行数据，根据不同类型的单元格数据（字符串、浮点数、整数、布尔值等），将其转换为字符串格式，将工作表名称及其内容逐行追加到字符串变量 `content` 中，在无法读取工作表时记录错误信息，并在最终结果中添加提示



### 7.2函数名: `read_excel_as_string_by_sheet`

#### 使用方法

**描述**:  按照Sheet读取excel文件中的所有内容，并以字符串形式返回

**参数**:  `file_path:<&str>` : excel文件路径

**返回值**:  

成功：`Result<Vec<String>>` : 成功时返回包含excel内容的字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_excel_as_string_by_sheet("src/test_examples/test_excel.xlsx");
match res {
    Ok(content) => println!("excel文件内容: \n {:?}", content),
    Err(e) => println!("读取excel文件失败: {}", e), 
}
 ```

#### 集成流程

传入文件路径，使用 `open_workbook_auto` 函数打开 Excel 文件，通过 `workbook.sheet_names()` 获取所有工作表的名称，并遍历每个工作表，通过 `worksheet_range` 方法获取工作表的范围，并遍历每一行数据，将每个工作表的内容逐行追加到字符串变量 `content` 中，并将每个工作表的 `content` 添加到向量 `contents` 中，通过在每行数据之间添加制表符 (`\t`) 和换行符 (`\n`)，使得输出内容格式清晰。将每个工作表的内容分别存储在一个向量中，方便后续处理



### 7.3函数名: `read_excel_by_column_as_string`

#### 使用方法

**描述**:  读取excel文件中的所有列的内容，并按列格式化为字符串，感觉这个函数意义不大

**参数**:  `file_path` : excel文件路径

**返回值**: 

成功： `Result<String>` : 成功时返回包含excel内容的字符串，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_excel_by_column_as_string("src/test_examples/test_excel.xlsx");
match res {
    Ok(content) => println!("excel文件内容: \n {:?}", content),
    Err(e) => println!("读取excel文件失败: {}", e), 
}
 ```

#### 集成流程

输入文件路径，使用 `open_workbook_auto` 函数打开 Excel 文件，通过 `workbook.sheet_names()` 获取所有工作表的名称，并遍历每个工作表，通过 `worksheet_range` 方法获取工作表的范围，并遍历每一行数据，根据不同类型的单元格数据（字符串、浮点数、整数、布尔值等），将其转换为字符串格式，将每个工作表的内容逐行追加到字符串变量 `row_content` 中，并将每个工作表的内容添加到向量 `sheets` 中，返回一个包含每个工作表内容的字符串向量的向量，每一行内容作为一个字符串



### 7.4函数名: `read_excel_by_row`

#### 使用方法

**描述**:  按行读取excel文件内容，每一行一个向量，每个元素用制表符分隔

**参数**:  `file_path` : Excel文件路径

**返回值**:  

成功：`Result<Vec<Vec<String>>>`: 成功时返回包含Excel内容的字符串向量，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_excel_by_row("src/test_examples/test_excel.xlsx");
match res {
    Ok(content) => println!("excel文件内容: \n {:?}", content),
    Err(e) => println!("读取excel文件失败: {}", e), 
}
 ```

#### 集成流程

输入文件路径，使用 `open_workbook_auto` 函数打开 Excel 文件，通过 `workbook.sheet_names()` 获取所有工作表的名称，并遍历每个工作表，通过 `worksheet_range` 方法获取工作表的范围，并遍历每一行数据，然后按列重新组织数据。根据不同类型的单元格数据（字符串、浮点数、整数、布尔值等），将其转换为字符串格式，将每个工作表的内容按列逐行追加到字符串变量 `col_content` 中，并将每个工作表的内容添加到向量 `sheets` 中，在无法读取工作表时记录错误信息，并将错误信息添加到当前工作表的内容中，返回一个包含每个工作表内容的字符串向量的向量



### 7.5函数名: `read_excel_by_column`

#### 使用方法

**描述**:  按列读取excel文件内容，每一列一个向量，每个元素用制表符分隔

**参数**:  `file_path:<&str>` : Excel文件路径

**返回值**:  

成功：`Result<Vec<Vec<String>>>` : 成功时返回包含Excel内容的字符串向量，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_excel_by_column("src/test_examples/test_excel.xlsx");
match res {
    Ok(content) => println!("excel文件内容: \n {:?}", content),
    Err(e) => println!("读取excel文件失败: {}", e), 
}
 ```

#### 集成流程

输入excel文件路径，使用 `open_workbook_auto` 函数打开 Excel 文件，通过 `workbook.sheet_names()` 获取所有工作表的名称，并遍历每个工作表，根据给定的行 (`block_rows`) 和列 (`block_cols`) 大小，按块读取数据，根据不同类型的单元格数据（字符串、浮点数、整数、布尔值等），将其转换为字符串格式，将每个工作表的内容按块逐行追加到字符串变量 `block_content` 中，并将每个块的内容添加到向量 `content` 中，在无法读取工作表时记录错误信息，并将错误信息添加到当前工作表的内容中，返回一个包含每个工作表内容的字符串向量



### 7.6函数名: `read_excel_by_block_as_string`

#### 使用方法

**描述**:  读取Excel文件中的内容并按块格式化为字符串，返回就是一个字符串，用来展示的

**参数**:  
	`file_path:<&str>` : Excel文件路径
	`block_size:(usize,usize)` : 读取块的大小 (rows, cols)

**返回值**:  

成功：`Result<String>` : 成功时返回包含Excel内容的字符串，失败时返回错误信息,只是返回一个字符串,块都是按行展开

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_excel_by_block_as_string("src/test_examples/test_excel.xlsx",(4,4));
match res {
    Ok(content) => println!("excel文件内容: \n {}", content),
    Err(e) => println!("读取excel文件失败: {}", e), 
}
 ```

#### 集成流程

确认Excel文件存在且类型正确。打开Excel，获取所有工作表名。遍历每个工作表，计算总行和总列数。按块读取，每块含指定行数和列数。每个单元格内容转换为字符串，添加到块内容中。每行后加制表符，每块后加换行符。若读取失败，记录错误并继续。所有内容汇总，返回结果字符串。



### 7.7函数名: `read_excel_by_block`

#### 使用方法

**描述**:  读取Excel文件中的内容并按块格式化为字符串

**参数**:  
	`file_path:<&str>` : excel文件路径
	`block_size:(usize,usize)` : 读取块的大小 (rows, cols)

**返回值**:  

成功：`Result<String>` : 成功时返回包含excel内容的字符串，失败时返回错误信息,每一个块是一个字符串

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_excel_by_block("src/test_examples/test_excel.xlsx",(4,4));
match res {
    Ok(content) => println!("excel文件内容: \n {:?}", content),
    Err(e) => println!("读取excel文件失败: {}", e), 
}
 ```

#### 集成流程

输入excel文件路径，使用 `open_workbook_auto` 函数打开 Excel 文件，通过 `workbook.sheet_names()` 获取所有工作表的名称，并遍历每个工作表，根据给定的行 (`block_rows`) 和列 (`block_cols`) 大小，按块读取数据，根据不同类型的单元格数据（字符串、浮点数、整数、布尔值等），将其转换为字符串格式，将每个工作表的内容按块逐行追加到字符串变量 `block_content` 中，并将每个块的内容添加到向量 `content` 中，在无法读取工作表时记录错误信息，并将错误信息添加到当前工作表的内容中，返回一个包含每个工作表内容的字符串向量



## 8.读取pptx文件

### 8.1函数名: `read_pptx_text`

#### 使用方法

**描述**:  从pptx文件中提取文本内容

**参数**:  `file_path:<&str>` : pptx文件路径

**返回值**:  

成功：`Result<String>`: 成功时返回包含PPTX内容的字符串，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_pptx_text("src/test_examples/test_ppt.pptx");
match res {
    Ok(content) => println!("pptx文件内容: \n {}", content),
    Err(e) => println!("读取pptx文件失败: {}", e), 
}
 ```

#### 集成流程

输入PPT文件路径，使用 Rust 标准库中的 `std::fs::File` 和 `std::path::Path` 来打开文件，使用 `zip` 库来读取压缩包内的文件，通过迭代 ZIP 文件中的每一个条目来查找特定的幻灯片 XML 文件，读取每个幻灯片文件的内容，并使用事件驱动的 XML 解析器来提取文本，将提取的文本内容追加到字符串变量 `slide_text` 中，并最终追加到 `slide_texts` 中，在文件读取或 XML 解析过程中出现错误时，使用 `?` 运算符传播错误。最后返回一个包含所有幻灯片文本内容的字符串



### 8.2函数名: `read_pptx_text_by_slide`

#### 使用方法

**描述**:  按页读取pptx文件内容，每一页一个向量

**参数**:  `file_path:<&str>` : PPTX文件路径

**返回值**:  

成功：`Result<Vec<String>>` : 成功时返回包含PPTX内容的字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::read_pptx_text_by_slide("src/test_examples/test_ppt.pptx");
match res {
    Ok(content) => println!("pptx文件内容: \n {:?}", content),
    Err(e) => println!("读取pptx文件失败: {}", e), 
}
 ```

#### 集成流程

输入PPT文件路径，打开文件，由于PPTX 文件是一个 ZIP 压缩包，因此使用 `zip` 库来读取压缩包内的文件，通过迭代 ZIP 文件中的每一个条目来查找特定的幻灯片 XML 文件，读取每个幻灯片文件的内容，并使用事件驱动的 XML 解析器来提取文本，将提取的文本内容追加到字符串变量 `slide_text` 中，并最终追加到 `slide_texts` 向量中，在文件读取或 XML 解析过程中出现错误时，使用 `?` 运算符传播错误。返回值为字符串向量，每一个字符串都是一张幻灯片的文本内容



### 8.3函数名: `read_pptx_notes`

#### 使用方法

**描述**:  读取ppt备注

**参数**:  `file_path:<&str>` : PPTX文件路径

**返回值**:  

成功：`Result<Vec<String>>` : 成功时返回包含PPTX备注的字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_pptx_text_by_notes("src/test_examples/test_ppt.pptx");
match res {
    Ok(content) => println!("pptx文件备注: \n {:?}", content),
    Err(e) => println!("读取pptx文件失败: {}", e), 
}
```

#### 集成流程

传入PPT文件路径，使用 Rust 标准库中的 `std::fs::File` 和 `std::path::Path` 来打开文件，通过 `ZipArchive` 管理 ZIP 文件内部的资源，通过迭代 ZIP 文件中的每一个条目来查找特定的备注 XML 文件，读取每个备注文件的内容，并使用事件驱动的 XML 解析器来提取文本，将提取的文本内容追加到字符串变量 `note_content` 中，并最终追加到 `notes` 向量中，在提取备注内容后，去除每条备注之后可能存在的数字序号和空白字符，在文件读取或 XML 解析过程中出现错误时，使用 `?` 运算符传播错误。返回结果为字符串向量，每个字符串为每张幻灯片备注的内容



## 9.读取zip文件

### 9.1函数名: `list_zip_filenames`

#### 使用方法

**描述**:  列出zip文件中所有文件目录

**参数**:  
	`file_path:<&str>`: zip文件路径
	`exclude_directories:<bool>` : 是否包含压缩包里的文件目录

**返回值**:  

成功：`Result<Vec<String>>` : 成功时返回包含zip所有文件目录的字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::list_zip_filenames("src/test_examples/test_zip.zip",true);
match res {
    Ok(content) => println!("zip文件中所以文件目录: \n {:?}", content),
    Err(e) => println!("读取zip文件失败: {}", e), 
}
 ```

#### 集成流程

输入json文件路径，打开文件，创建缓冲区，遍历json文件每一行内容，使用`from_str`函数解析每一行字符串，返回`serde_json::Value`类型数据。每一行数据就是一个`Value`,最终返回类型为`Value`的向量



### 9.2函数名: `read_zip_txt`

#### 使用方法

**描述**:  一次性读取zip内文本文件内容

**参数**:  
	`file_path:<&str>` : zip文件路径
	`file_name:<&str>`: 要打开的文本文件的路径

**返回值**:  

成功：`Result<String>` : 成功时返回包含指定的zip文本文件内容的字符串，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_txt("src/test_examples/test_zip.zip","test_rar/test_txt.txt");
match res {
	Ok(content) => println!("zip文件中指定文本文件的内容: \n {}", content),
	Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

第一个函数，接受两个字符串参数，将它们拼接成一个完整的路径，使用 `to_string_lossy()` 将 `PathBuf` 转换为字符串，并替换掉反斜杠 (`\`) 为正斜杠 (`/`)，以确保在不同操作系统上的一致性。第二个函数，接受压缩包文件路径和压缩包中相应文件的路径，通过 `by_name` 方法打开 ZIP 文件中的指定文件，并使用缓冲读取器读取文件内容，返回一个包含指定文件内容的字符串



### 9.3函数名: `read_zip_txt_by_line`

#### 使用方法

**描述**:  按行读取文本文件内容

**参数**:  
	`zip_path:<&str>` : zip文件路径
	`file_name:<&str>` : 要打开的文本文件的路径

**返回值**:  

成功：`Result<Vec<String>>` : 成功时返回包含指定的zip文本文件内容的字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_txt_by_line("src/test_examples/test_zip.zip","test_rar/test_txt.txt");
match res {
	Ok(content) => println!("zip文件中指定文本文件的内容: \n {:?}", content),
	Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

这个函数首先确认ZIP文件存在且为正确类型，然后打开文件并创建ZIP归档读取器。接下来，它从ZIP档案中打开指定的文件，并设置缓冲读取器逐行读取内容。每读取一行，就去除行尾的换行符并存储到一个列表中。读取直到文件末尾，最后返回包含所有行内容的列表，或在遇到错误时返回错误详情。整个过程确保了从ZIP文件中准确读取文本文件的每一行数据。



### 9.4函数名: `read_zip_txt_by_byte`

#### 使用方法

**描述**:  按字节读取zip内文本文件内容

**参数**:  
	`zip_path:<&str>` : zip文件路径
	`file_name:<&str>` : 要打开的文本文件的路径

**返回值**:  

成功：`Result<Vec<u8>>`: 成功时返回包含指定的zip文本文件内容的字节数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_txt_by_byte("src/test_examples/test_zip.zip","test_rar/test_txt.txt");
match res {
	Ok(content) => println!("zip文件中指定文本文件的内容: \n {:?}", content),
	Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

函数开始时检查ZIP文件的有效性，确保路径正确且文件类型为ZIP。随后，它安全地打开ZIP文件并初始化归档读取器。接着，定位并打开归档内指定的文件，准备按字节读取。

读取过程使用缓冲读取器，每次读取一个字节或字节块至预定义的缓冲区。读取的每个有效字节或字节块被追加到一个动态增长的列表中。此过程持续至文件末尾，或在遇到读取错误时返回错误。最终，该函数返回一个包含文件完整内容的字节列表，实现了从ZIP文件中逐字节读取指定文件的全部数据。



### 9.5函数名: `read_zip_txt_by_block`

#### 使用方法

**描述**:  按块读取zip文件内文本文件

**参数**:  
	`zip_path:<&str>`: 文件路径
	`file_name:<&str>`: 要打开的文本文件的路径
	`block_size:<usize>` : 每次读取的块大小，以字节为单位

**返回值**:  

成功：`Result<Vec<String>>` : 返回一个包含每个块的向量，每个块都是一个字符串

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_txt_by_byte("src/test_examples/test_zip.zip","test_rar/test_txt.txt",4);
match res {
	Ok(content) => println!("zip文件中指定文本文件的内容: \n {:?}", content),
	Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

此函数首先检查ZIP文件的存在性和类型，确保其为正确的ZIP文件。通过验证后，函数将ZIP文件安全打开，并创建一个ZIP归档读取器。接着，定位并打开归档中指定的文件，准备按块读取内容。

读取过程使用缓冲读取器，每次读取一个固定大小的块，该大小由`block_size`参数指定。读取的字节数据存储于预先定义的缓冲区`buffer`中，每次读取后，将`buffer`中实际读取到的字节数据转换为字符串，并添加至结果列表`blocks`中。此过程持续进行，直至文件末尾或读取遇到错误。

函数最终返回一个字符串列表`blocks`，其中每个字符串表示按`block_size`读取的文件内容块。这种方式适用于高效读取大文件，同时确保文件内容的完整性和正确性。通过按块读取，不仅优化了内存使用，还便于处理大型文本文件或进行数据批处理操作。



### 9.6函数名: `read_zip_csv`

#### 使用方法

**描述**:  按行读取zip内csv文件内容

**参数**:  
	`zip_path:<&str>`: 文件路径
	`file_name:<&str>`: 要打开的csv文件的路径

**返回值**: 

成功： `Result<Vec<Vec<String>>>`：返回一个二维字符串数组

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_csv("src/test_examples/test_zip.zip","test_rar/test_csv.csv");
match res {
    Ok(content) => println!("zip文件中指定csv文件的内容: \n {:?}", content),
    Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

接受压缩包文件路径和压缩包中相应CSV文件的路径，使用 Rust 标准库中的 `std::fs::File` 和 `std::path::Path` 来打开文件，ZIP 文件通过 `zip` 库来读取压缩包内的文件，通过 `by_name` 方法打开 ZIP 文件中的指定文件，并使用 CSV 读取器读取文件内容，使用 CSV 读取器的 `records` 方法来读取每一行记录，并将每一行转换为字符串向量，每一行 CSV 记录被转换为一个字符串向量，使得数据更容易处理。最后返回一个包含所有 CSV 记录的二维字符串向量



### 9.7函数名: `read_zip_csv_by_column`

#### 使用方法

**描述**:  按列读取zip中csv文件内容，默认是没有读取列名的

**参数**:  
	`zip_path:<&str>`: 文件路径
	`file_name:<&str>`: 要打开的csv文件的路径

**返回值**: 

成功： `Result<Vec<Vec<String>>>`：返回一个二维字符串数组

失败： 文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_csv_by_column("src/test_examples/test_zip.zip","test_rar/test_csv.csv");
match res {
    Ok(content) => println!("zip文件中指定csv文件的内容: \n {:?}", content),
    Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

首先验证ZIP文件的可用性和类型，确保文件存在并为ZIP格式。通过验证后，ZIP文件被安全打开，并创建一个ZIP归档读取器，以便访问其内容。定位并打开归档中指定的CSV文件。使用`csv`库的`ReaderBuilder`初始化一个CSV读取器，准备读取文件。读取器按行遍历CSV文件，将每行数据转换为`Vec<String>`，并存储在`records`列表中，构建完整的行数据集合。

完成按行读取后，流程进入按列转换阶段，以支持后续的数据分析或处理需求。首先，初始化一个由空列表组成的`columns`向量，其长度与CSV的列数相匹配。然后，遍历`records`列表中的每一行，将每行数据按列拆分并归类至相应的`columns`列表中，实现数据的按列组织。

最后，返回包含所有按列分类数据的`columns`列表。



### 9.8函数名: `read_zip_csv_by_block`

#### 使用方法

**描述**:  按块读取zip中csv文件内容

**参数**:  
	`zip_path:<&str>`: 文件路径
	`file_name:<&str>`: 要打开的csv文件的路径
	`block_size:<usize>` : 每次读取的块大小，以字节为单位

**返回值**: 

成功： `Result<Vec<Vec<Vec<String>>>>`：返回一个向量，每个向量元素即为csv文件块的内容，用二维向量存储

失败： 文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_csv_by_block("src/test_examples/test_zip.zip","test_rar/test_csv.csv",4);
match res {
	Ok(content) => println!("zip文件中指定csv文件的内容:\n {:?}", content),
	Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

验证与准备，确认ZIP文件存在且类型正确。ZIP文件读取，使用标准库函数打开ZIP文件并创建归档读取器。定位CSV文件，在归档中找到指定的CSV文件并准备读取。初始化容器，设置用于存储块数据的`blocks`和当前块`current_block`。逐行读取与块构建，逐行读取CSV内容，每读取一行就转换为字符串向量并添加到`current_block`，当`current_block`的行数等于预设的`block_size`时，将其添加到`blocks`，并清空`current_block`。

处理尾块，遍历结束后，如果`current_block`非空，将其作为最后一个块保存到`blocks`中。返回结果，最终返回按块组织的CSV数据`blocks`。



### 9.9函数名: `read_zip_json`

#### 使用方法

**描述**:  动态读取zip中json文件

**参数**:  
	`zip_path:<&str>`  : 文件路径
	`file_name:<&str>`  : 要打开的json文件的路径

**返回值**:  

成功：`serde_json::Result<Value>` ：返回Value，Value包含整个json文件的内容

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_json("src/test_examples/test_zip.zip","test_rar/test_json.json");
match res {
    Ok(content) => println!("zip文件中指定json文件的内容:\n {:?}", content),
    Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

接受压缩包文件路径和压缩包中相应文件的路径，使用 Rust 标准库中的 `std::fs::File` 和 `std::path::Path` 来打开文件，使用 `BufReader` 包装 `File`，提高大文件的读取效率，使用 `serde_json` 库的 `from_reader` 方法直接从 `BufReader` 中解析 JSON 数据，使用 `serde_json::Result<Value>` 返回类型，确保函数返回一个结果，其中包含了可能发生的错误。返回通用的 JSON 数据结构`serde_json::Value`，存储JSON文件内容



### 9.10函数名: `read_zip_json_by_block`

#### 使用方法

**描述**:  按块读取json文件

**参数**:  
	`zip_path:<&str>` : 文件路径
	`file_name:<&str>`  : 要打开的json文件的路径
	`block_size:<usize>` : 每次读取的块大小，以字节为单位

**返回值**:  

成功：`Result<Vec<Vec<Value>>>`：返回包含每个块的向量，每个块都是一个对象向量

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_json_by_block("src/test_examples/test_zip.zip","test_rar/test_json.json",4);
match res {
 	Ok(content) => println!("zip文件中指定json文件的内容: \n {:?}", content),
 	Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

验证与准备：确保ZIP文件存在且类型正确。打开ZIP文件：使用`File::open`打开文件，创建`ZipArchive`实例。定位并读取JSON文件：在归档中找到指定文件，使用`BufReader`读取。解析JSON内容：读取文件内容到字符串，使用`serde_json`将字符串反序列化为`Value`类型，确保内容为数组。按块构建JSON数据：初始化`blocks`和`current_block`容器，遍历JSON数组的`Value`，每`block_size`个元素就将`current_block`添加到`blocks`，并清空`current_block`。处理尾部数据：如果最后读取的`current_block`非空，将其添加到`blocks`。返回结果：返回按块组织的JSON数据`blocks`



### 9.11函数名: `read_zip_jsonl`

#### 使用方法

**描述**:  按行读取zip内jsonl文件

**参数**:  
	`zip_path:<&str>`: 文件路径
	`file_name:<&str>`: 要打开的jsonl文件的路径

**返回值**: 

成功： `Result<Vec<Value>>`：返回Value数组，Value数组包含整个jsonl文件的内容

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_jsonl("src/test_examples/test_zip.zip","test_rar/test_jsonline.jsonl");
match res {
    Ok(content) => println!("zip文件中指定jsonl文件的内容: \n {:?}", content),
    Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

接受压缩包文件路径和压缩包中相应文件的路径，打开文件，通过 `ZipArchive` 管理 ZIP 文件内部的资源，使用 `BufReader` 包装 `File`，提高大文件的读取效率，逐行读取JSONL文件，使用 `lines` 方法逐行读取文件内容，并对每一行进行解析，使用 `serde_json` 库的 `from_str` 方法逐行解析 JSON数据，使用 `Result` 类型返回结果，确保函数可以正确处理文件打开、解压和 JSON 解析过程中的任何错误



### 9.12函数名: `read_zip_xml_text`

#### 使用方法

**描述**:  直接读取zip文件中xml文件内容

**参数**:  
	`zip_path:<&str>`: 文件路径
	`file_name:<&str>`: 要打开的xml文件的路径

**返回值**:  

成功：`Result<String>`：返回一个字符串，字符串中包含指定xml文件全部内容

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_xml_text("src/test_examples/test_zip.zip","test_rar/test_xml.xml");
match res {
	Ok(content) => println!("zip文件中指定xml文件的内容:\n {}", content),
	Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

首先，进行验证和准备，确认ZIP文件存在且为正确的类型。接着，使用`File::open`函数打开ZIP文件，并创建`ZipArchive`实例以处理归档文件。定位并读取XML文件，通过`by_name`方法在ZIP归档中找到指定文件，并使用`BufReader`缓冲读取器读取文件内容。读取文件内容，创建一个`String`对象`content`，使用`read_to_string`方法将文件数据读取到`content`中。最后，返回读取到的XML文件内容。



### 9.13函数名: `read_zip_xml`

#### 使用方法

**描述**:  按事件处理读取zip文件中xml文件内容

**参数**:  
	`zip_path:<&str>`: 文件路径
	`file_name:<&str>`: 要打开的xml文件的路径
	`on_start:<FnMut(&str)>`: 处理Start事件的函数
	`on_text:<FnMut(&str)>`: 处理Text事件的函数
	`on_end:<FnMut(&str)>`: 处理End事件的函数

**返回值**:  

成功：`Result<()>`：无返回值

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
// 读取xml文件标签
let mut start_tags:Vec<String> = Vec::new();
let mut end_tags:Vec<String> = Vec::new();
let mut text:Vec<String> = Vec::new();
// 处理标签的闭包
let on_start = |tag_name:&str|{
    start_tags.push(tag_name.to_string());
};
let on_end = |tag_name:&str| {
    end_tags.push(tag_name.to_string());
};
let on_text = |text_content:&str| {
    text.push(text_content.to_string());
};

let res = FileReader::read_zip_xml("src/test_examples/test_zip.zip", "test_rar/test_xml.xml", on_start, on_text, on_end);
match res {
    Ok(()) => {
        println!("Start tags:");
        for start in start_tags {
            println!("  {}", start);
        }

        println!("Text nodes:");
        for text in text {
            println!("  {}", text);
        }

        println!("end tags:");
        for end in end_tags {
            println!("  {}", end);
        }
    },
    Err(e) => eprintln!("Error processing XML: {}", e),
}
```

#### 集成流程

传入压缩包文件路径和压缩包中相应文件的路径，同时传入三个泛型参数 `S`, `T`, `E` 分别对应于 XML 的开始标签、文本节点和结束标签的回调函数，通过 `zip` 库来读取压缩包内的文件，通过使用缓冲读取器 `BufReader`，使用 `quick_xml` 库的 `Reader` 结构体来解析 XML 数据，使用 `Result` 类型返回结果，确保函数可以正确处理文件打开、解压和 XML 解析过程中的任何错误。回调机制，当遇到开始标签、文本节点和结束标签时，分别调用用户提供的回调函数



### 9.14函数名: `read_zip_markdown`

#### 使用方法

**描述**:  一次性读取zip文件中md文件内容

**参数**:  
	`zip_path:<&str>`: 文件路径
	`file_name:<&str>`: 要打开的md文件的路径

**返回值**:  

成功：`Result<String>`：返回一个字符串，字符串中包含指定md文件全部内容

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_markdown("src/test_examples/test_zip.zip","test_rar/test_md.md");
match res {
    Ok(content) => println!("zip文件中指定md文件的内容: \n {}", content),
    Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

传入压缩包文件路径和压缩包中相应文件的路径，使用 Rust 标准库中的 `std::fs::File` 和 `std::path::Path` 来打开文件，通过 `zip` 库来读取压缩包内的文件，使用 `BufReader` 包装 `File`，使用 `read_line` 方法逐行读取文件内容，并去除每行结尾的换行符。最后返回字符串向量，每一个字符串表示文件一行内容



### 9.15函数名: `read_zip_md_by_line`

#### 使用方法

**描述**:  按行读取zip文件中md文件内容

**参数**:  
	`zip_path:<&str>`: 文件路径
	`file_name:<&str>`: 要打开的md文件的路径

**返回值**:  

成功：`Result<Vec<String>>`：返回一个字符串数组，每个字符串中包含指定md文件的内容

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_md_by_line("src/test_examples/test_zip.zip","test_rar/test_md.md");
match res {
    Ok(content) => println!("zip文件中指定md文件的内容: \n {:?}", content),
    Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

验证与准备，确认ZIP文件存在且类型正确。使用`File::open`读取ZIP文件，随后构建`ZipArchive`实例。在ZIP归档中定位目标MD文件，创建缓冲读取器`BufReader`以优化读取。逐行读取MD文件内容，每次读取一行后，去除行尾换行符，存储处理后的行内容至`Vec<String>`。读取到文件末尾时，跳出循环；若读取过程中遇到错误，立即返回错误。最终，将逐行读取并处理的MD文件内容列表`lines`作为结果返回。



### 9.16函数名: `read_zip_md_by_byte`

#### 使用方法

**描述**:  按字节读取zip文件中md文件内容

**参数**:  
	`zip_path:<&str>` : 文件路径
	`file_name:<&str>` : 要打开的md文件的路径

**返回值**:  

成功：`Result<Vec<u8>>`：返回一个u8字节数组，包含指定md文件全部内容

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_md_by_byte("src/test_examples/test_zip.zip","test_rar/test_md.md");
match res {
       Ok(content) => println!("zip文件中指定md文件的内容: \n {:?}", content),
       Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

检查ZIP文件路径有效性与文件类型，初始化ZIP文件与档案实例，在ZIP中找到指定文件，逐字节读取文件内容，输出字节数据或错误信息。



### 9.17函数名: `read_zip_md_by_block`

#### 使用方法

**描述**:  按块读取zip文件中markdown文件内容

**参数**:  
	`zip_path:<&str>`: 文件路径
	`file_name:<&str>`: 要打开的md文件的路径
	`block_size:<usize>`: 每次读取的块大小，以字节为单位

**返回值**:  

成功：`Result<Vec<String>>`：返回指定markdown文件内容的字符串数组

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_md_by_block("src/test_examples/test_zip.zip","test_rar/test_md.md",4);
match res {
    Ok(content) => println!("zip文件中指定md文件的内容: \n {:?}", content),
    Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

开始时，系统验证ZIP文件的存在性和类型正确性。随后，使用`File::open`函数来读取ZIP文件，并基于此创建`ZipArchive`实例。定位到ZIP归档中的指定文件，建立缓冲读取器`BufReader`。创建一个字节大小的缓冲数组`buffer`，并初始化一个字节列表`bytes`。进入循环读取阶段，使用`read`方法按字节读取文件。当读取到文件末尾（读取字节数为0）时，结束循环。若读取的字节数为1，则直接将字节添加到`bytes`列表中。若读取的字节数大于1，将读取到的字节切片添加到`bytes`列表。若读取过程中遇到错误，则返回该错误。最后，将读取到的字节列表`bytes`作为结果返回。



### 9.18函数名: `read_zip_pdf_as_string`

#### 使用方法

**描述**:  按块读取zip文件中md文件内容

**参数**:  
	`zip_path:<&str>`: 文件路径
	`file_name:<&str>`: 要打开的pdf文件的路径

**返回值**:  

成功：`Result<String>`：返回指定pdf文件内容的字符串

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_pdf_as_string("src/test_examples/test_zip.zip","test_rar/test_pdf.pdf");
match res {
    Ok(content) => println!("zip文件中指定pdf文件的内容: \n {}", content),
    Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

首先，检查ZIP文件存在性与类型正确性。接着，打开ZIP文件，创建`ZipArchive`实例。遍历ZIP归档中的所有文件，查找与`file_name`匹配的PDF文件。找到PDF文件后，确认其类型正确。创建临时目录，用于存放PDF文件的临时版本。读取ZIP中的PDF文件内容，写入到临时文件中。从临时文件中读取PDF内容，调用`extract_text`函数提取文本。若`extract_text`成功，返回处理后的PDF文本内容。若`extract_text`失败，返回错误信息。若遍历ZIP归档未找到匹配的PDF文件，返回“PDF文件不存在”的错误。



### 9.19函数名: `read_zip_excel`

#### 使用方法

**描述**:  按块读取zip文件中excel文件内容

**参数**:  
	`zip_path:<&str>`: 文件路径
	`file_name:<&str>`: 要打开的excel文件的路径

**返回值**:  

成功：`Result<Vec<String>>`：返回指定excel文件内容的字符串数组

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_excel("src/test_examples/test_zip.zip","test_rar/test_excel.xlsx");
match res {
    Ok(content) => println!("zip文件中指定excel文件的内容: \n {:?}", content),
    Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

输入压缩包文件路径`zip_path`即和压缩包中相应文件的路径`file_name`，使用 Rust 标准库来打开文件，通过 `zip` 库来读取压缩包内的文件，使用 `BufReader` 包装 `File`，提高大文件的读取效率，使用 `calamine` 库来读取 Excel 文件的内容，使用 `calamine` 库遍历每一个工作表，并将每一行内容作为一个字符串存储到向量中。最后返回字符串向量，其中每一个字符串为excel表中一行内容



### 9.20函数名: `read_zip_pptx_text`

#### 使用方法

**描述**:  读取zip文件中ppt内容,返回一个字符串，便于展示

**参数**:  
	`zip_path:<&str>` : 文件路径
	`file_name:<&str>` : 要打开的ppt文件的路径

**返回值**:  

成功：`Result<String>` ：返回指定ppt文件内容的字符串

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_pptx_text("src/test_examples/test_zip.zip","test_rar/test_ppt.pptx");
match res {
    Ok(content) => println!("zip文件中指定ppt文件的内容: \n {}", content),
    Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

验证ZIP文件存在与正确类型。打开ZIP文件，创建`ZipArchive`实例。找到指定PPTX文件并读取其内容到缓冲区。使用`Cursor`包装缓冲区，支持读取操作。从`Cursor`创建新的`ZipArchive`。遍历PPTX中的所有文件，定位到幻灯片XML文件。读取并解析每个幻灯片的XML内容。提取文本，整合到结果字符串中。返回所有幻灯片提取的文本。



### 9.21函数名: `read_zip_pptx_text_by_slide`

#### 使用方法

**描述**:  读取zip文件中ppt内容,返回一个字符串，便于展示

**参数**:  
	`zip_path:<&str>`: 文件路径
	`file_name:<&str>` - ZIP文件内部PPTX文件的路径（相对路径）

**返回值**:  

成功：`Result<Vec<String>>` - 返回指定pptx文件中提取的所有幻灯片文本内容，每一页一个向量

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_pptx_text_by_slide("src/test_examples/test_zip.zip","test_rar/test_ppt.pptx");
match res {
    Ok(content) => println!("zip文件中指定pptx文件的内容: \n {:?}", content),
    Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

验证ZIP文件存在并确认为ZIP类型。读取ZIP中指定PPTX文件内容至缓冲区。使用`Cursor`包裹缓冲区，创建新的`ZipArchive`。遍历PPTX文件，定位至幻灯片XML文件。读取并解析每个XML文件，提取文本。将每张幻灯片文本存储至向量列表中。返回存储所有幻灯片文本的向量列表。



### 9.22函数名: `read_zip_pptx_notes`

#### 使用方法

**描述**:  读取ZIP文件中ppt备注

**参数**:  
	`zip_path:<&str>`: 文件路径
	`file_name:<&str>`: 要打开的pptx文件的路径

**返回值**:  

成功：`Result<Vec<String>>`：返回指定pptx文件备注的字符串数组

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_zip_pptx_notes("src/test_examples/test_zip.zip","test_rar/test_ppt.pptx");
match res {
    Ok(content) => println!("zip文件中指定ppt文件的内容: \n {:?}", content),
    Err(e) => println!("读取zip文件失败: {}", e), 
}
```

#### 集成流程

验证ZIP文件存在，确认为ZIP类型。读取指定PPTX文件到内存缓冲区。使用`Cursor`创建`ZipArchive`。遍历PPTX文件，定位至备注幻灯片XML。读取并解析每个XML文件，关注文本节点。收集文本，每条文本后添加换行符。处理文本，去除尾部数字和空白，存储至列表。返回存储所有备注内容的向量列表。



## 10.读取rar文件

### 10.1函数名: `list_rar_filenames`

#### 使用方法

**描述**:  列出 RAR 文件中的所有文件和目录

**参数**:  
	`file_path:<&str>`: RAR 文件的路径
	`exclude_directories:<bool>`: 是否包含压缩包里的文件目录

**返回值**:  

成功：`Result<Vec<String>, Box<dyn Error>>`: 成功时返回文件和目录的名称列表，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

 ```rust
use FileContentReader::FileReader;
let res = FileReader::list_rar_filenames("src/test_examples/test_rar.rar",true);
match res {
    Ok(content) => println!("rar文件中所有文件和目录: \n {:?}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
 ```

#### 集成流程

传入RAR压缩包文件路径，是否包含目录参数，使用 `unrar` 库来处理 RAR 文件，通过 `Archive::new` 创建一个 RAR 归档对象，管理 RAR 文件内部的资源。然后使用 `open_for_listing` 方法打开归档文件进行列表展示，使用 `filter_map` 方法过滤出需要的文件名，并转换为字符串。最后返回结果，列出RAR压缩包下所有文件目录结构和文件

### 10.2函数名: `read_rar_txt`

#### 使用方法

**描述**:  读取rar压缩包内的txt文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的文本文件的路径

**返回值**:  

成功：`UnrarResult<String, Box<dyn UnrarError>>`: 成功时返回文件文本内容，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_txt("src/test_examples/test_rar.rar","test_rar\\test_txt.txt");
match res {
    Ok(content) => println!("rar文件中指定txt文件的内容: \n {}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

借助`FileContentReader::FileReader`工具，调用`read_rar_txt`功能定位并读取RAR文件内部的具体TXT文件。根据返回结果，成功读取则显示TXT文件内容，读取失败则报告错误信息，实现了对RAR压缩包内TXT文件的精确读取。

### 10.3函数名: `read_rar_txt_by_line`

#### 使用方法

**描述**:  按行读取rar文件中txt文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的文本文件的路径

**返回值**:  

成功：`UnrarResult<Vec<String>, Box<dyn UnrarError>>`: 成功时返回包含指定的rar文本文件内容的字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_txt_by_line("src/test_examples/test_rar.rar","test_rar\\test_txt.txt");
match res {
    Ok(content) => println!("rar文件中指定txt文件的内容: \n {:?}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

利用`FileContentReader::FileReader`的`read_rar_txt_by_line`方法，逐行读取RAR文件中指定的TXT文件内容。根据调用结果，若读取无误则逐行输出TXT内容，遇到错误则输出读取失败信息，实现了从RAR文件中精确读取TXT文件的逐行数据。

### 10.4函数名: `read_rar_txt_by_byte`

#### 使用方法

**描述**:  按字节读取rar文件中txt文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的文本文件的路径

**返回值**:  

成功： `UnrarResult<Vec<u8>, Box<dyn UnrarError>>`: 成功时返回包含指定的rar文本文件内容的字节数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_txt_by_byte("src/test_examples/test_rar.rar","test_rar\\test_txt.txt");
match res {
    Ok(content) => println!("rar文件中指定txt文件的内容: \n {:?}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

通过`FileContentReader::FileReader`的`read_rar_txt_by_byte`方法，按字节读取RAR文件内指定TXT文件。依据操作结果，读取成功则输出TXT文件的字节内容，读取失败则显示错误信息，实现了对RAR压缩文件中TXT文件的字节级读取。

### 10.5函数名: `read_rar_txt_by_block`

#### 使用方法

**描述**:  按块读取rar文件中txt文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的文本文件的路径
	`block_size:<usize>`: 每次读取的块大小，以字节为单位

**返回值**:  

成功：`UnrarResult<Vec<String>, Box<dyn UnrarError>>`: 成功时返回一个包含每个块的向量，每个块都是一个字符串，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_txt_by_block("src/test_examples/test_rar.rar","test_rar\\test_txt.txt",4);
match res {
    Ok(content) => println!("rar文件中指定txt文件的内容: \n {:?}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

应用`FileContentReader::FileReader`中的`read_rar_txt_by_block`函数，按照设定的块大小（本例为4），分块读取RAR文件里的指定TXT文件。依据执行情况，正确读取后打印分块内容，如遇错误则展示读取失败细节，实现RAR包内TXT文件的块状读取机制。

### 10.6函数名: `read_rar_csv`

#### 使用方法

**描述**:  读取rar压缩包中csv文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的csv文件的路径

**返回值**:  

成功：`UnrarResult<Vec<Vec<String>>, Box<dyn UnrarError>>`: 成功时返回一个二维字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_csv("src/test_examples/test_rar.rar","test_rar\\test_csv.csv");
match res {
    Ok(content) => println!("rar文件中指定csv文件的内容: \n {:?}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

运用`FileContentReader::FileReader`模块下的`read_rar_csv`功能，专门读取RAR文件中包含的CSV文件。处理结果方面，若读取过程无异常，则直接呈现CSV文件内容；反之，出现任何错误即反馈读取失败的信息，从而达到高效读取RAR存档内CSV文件的目的。

### 10.7函数名: `read_rar_csv_by_column`

#### 使用方法

**描述**:  按列读取csv文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的csv文件的路径

**返回值**:  

成功：`UnrarResult<Vec<Vec<String>>, Box<dyn UnrarError>>`: 成功时返回一个二维字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_csv_by_column("src/test_examples/test_rar.rar","test_rar\\test_csv.csv");
match res {
    Ok(content) => println!("rar文件中指定csv文件的内容: \n {:?}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

采用`FileContentReader::FileReader`库中的`read_rar_csv_by_column`方法，针对RAR文件里存储的CSV文件，按列读取其内容。基于执行状况，成功读取则输出CSV各列信息，若读取过程中遭遇问题，则返回相应错误详情，达成了对RAR压缩文件中CSV文件的列式读取能力。

### 10.8函数名: `read_rar_csv_by_block`

#### 使用方法

**描述**:  按块读取rar中csv文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的csv文件的路径
	`block_size:<usize>`: 每次读取的块大小，以字节为单位

**返回值**:  

成功：`UnrarResult<Vec<Vec<Vec<String>>>, Box<dyn UnrarError>>`: 成功时返回一个向量，每个向量元素即为csv文件块的内容，用二维向量存储，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_csv_by_block("src/test_examples/test_rar.rar","test_rar\\test_csv.csv",4);
match res {
    Ok(content) => println!("rar文件中指定csv文件的内容: \n {:?}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

借助`FileContentReader::FileReader`的`read_rar_csv_by_block`功能，按照预设的区块大小（此处为4），分段读取RAR文件内的CSV文件数据。依循操作结果，读取成功时展现CSV文件按区块分割的内容，若读取失败则报告具体的错误信息，实现了对RAR归档中CSV文件的区块读取策略。

### 10.9函数名: `read_rar_json`

#### 使用方法

**描述**:  读取rar中json文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的json文件的路径

**返回值**:  

成功：`UnrarResult<Value, Box<dyn UnrarError>>`: 成功时返回Value，Value包含整个json文件的内容，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_json("src/test_examples/test_rar.rar","test_rar\\test_json.json");
match res {
    Ok(content) => println!("rar文件中指定json文件的内容: \n {:?}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

利用`FileContentReader::FileReader`中的`read_rar_json`函数，直接读取RAR文件夹下指定的JSON文件。依据调用结果，成功读取时输出JSON文件内容，遇到读取错误则显示详细的错误信息，有效实现了从RAR档案精准读取JSON文件的需求。

### 10.10函数名: `read_rar_json_by_block`

#### 使用方法

**描述**:  按块读取json文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的json文件的路径
	`block_size:<usize>`: 每次读取的块大小，以字节为单位

**返回值**:  

成功：`UnrarResult<Vec<Vec<Value>>, Box<dyn UnrarError>>`: 成功时返回包含每个块的向量，每个块都是一个对象向量，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_json_by_block("src/test_examples/test_rar.rar","test_rar\\test_json.json",4);
match res {
    Ok(content) => println!("rar文件中指定json文件的内容: \n {:?}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

通过`FileContentReader::FileReader`的`read_rar_json_by_block`功能，以指定的区块大小（此处为4）分段读取RAR文件中的JSON文件。根据执行结果，若读取无误，将以区块形式展示JSON文件内容；若发生错误，则返回读取失败的具体原因，实现了对RAR封装内JSON文件的区块读取操作。

### 10.11函数名: `read_rar_jsonl`

#### 使用方法

**描述**:  列出 RAR 文件中的所有文件和目录

**参数**:  
	`file_path:<&str>`: RAR 文件的路径
	`exclude_directories:<bool>`: 是否包含压缩包里的文件目录

**返回值**:  

成功：`UnrarResult<Vec<Value>, Box<dyn UnrarError>>`: 成功时返回Value数组，Value数组包含整个jsonl文件的内容，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_jsonl("src/test_examples/test_rar.rar","test_rar\\test_json.json");
match res {
    Ok(content) => println!("rar文件中指定jsonl文件的内容: \n {:?}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

运用`FileContentReader::FileReader`的`read_rar_jsonl`方法，读取RAR文件中指定的JSON Lines（jsonl）格式文件。读取结果若为成功，将输出jsonl文件的全部内容；若读取过程中出现错误，则会返回相应的错误信息，确保了从RAR文件中高效读取jsonl文件的能力。

### 10.12函数名: `read_rar_xml_text`

#### 使用方法

**描述**:  从rar读取xml文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的xml文件的路径

**返回值**:  

成功：`UnrarResult<String, Box<dyn UnrarError>>`: 成功时返回一个字符串，字符串中包含指定xml文件全部内容，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_xml_text("src/test_examples/test_rar.rar","test_rar\\test_json.json");
match res {
    Ok(content) => println!("rar文件中指定xml文件的内容: \n {}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

采用`FileContentReader::FileReader`的`read_rar_xml_text`函数尝试读取RAR文件中的XML文本。若读取过程顺利，将直接打印出XML文件的文本内容；如遇读取错误，则反馈读取失败的错误信息，确保能够针对性地处理RAR包内XML文件阅读任务。

### 10.13函数名: `read_rar_xml`

#### 使用方法

**描述**:  按事件读取xml文件内容

**参数**:  
	`rar_path:<&str>`: 文件路径
	`file_name:<&str>`: 要打开的xml文件的路径
	`on_start:<FnMut(&str)>`: 处理Start事件的函数
	`on_text:<FnMut(&str)>`: 处理Text事件的函数
	`on_end:<FnMut(&str)>`: 处理End事件的函数

**返回值**:  

成功：`Result<()>`：无返回值

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
// 读取xml文件标签
let mut start_tags:Vec<String> = Vec::new();
let mut end_tags:Vec<String> = Vec::new();
let mut text:Vec<String> = Vec::new();
// 处理标签的闭包
let on_start = |tag_name:&str|{
    start_tags.push(tag_name.to_string());
};
let on_end = |tag_name:&str| {
    end_tags.push(tag_name.to_string());
};
let on_text = |text_content:&str| {
    text.push(text_content.to_string());
};
let res = FileReader::read_rar_xml("src/test_examples/test_rar.rar","test_rar\\test_xml.xml", on_start, on_text, on_end);
match res {
    Ok(()) => {
        println!("Start tags:");
        for start in start_tags {
            println!("  {}", start);
        }
        println!("Text nodes:");
        for text in text {
            println!("  {}", text);
        }
        println!("end tags:");
        for end in end_tags {
            println!("  {}", end);
        }
    },
    Err(e) => eprintln!("Error processing XML: {}", e),
}
```

#### 集成流程

该代码片段旨在深度解析RAR压缩包内的XML文件结构。首先，初始化三个向量（`start_tags`, `end_tags`, 和 `text`），用于存储XML文件的开始标签、结束标签及其中间包含的文本信息。定义了三个处理回调函数（闭包）：`on_start`、`on_text` 和 `on_end`。这些函数在读取XML的过程中被触发，分别捕获遇到每个开始标签、文本节点和结束标签时的数据，将它们存储至对应的向量中。核心部分调用了`FileContentReader::FileReader`模块下的`read_rar_xml`函数，指定要读取的RAR文件位置及其内部的XML文件路径，同时传入上述闭包作为处理参数。这意味着每当读取器识别到一个XML标记点时，就会自动调用相应的闭包，实现数据的动态捕获与存储。最终，如果读取及解析过程顺利完成（`Ok(())`表示成功），循环遍历收集的`start_tags`、`text` 和 `end_tags` 向量，逐行打印所有开始标签、对应文本节点以及结束标签的信息，完整展现XML文件的结构细节。反之，若读取过程中遭遇任何异常情况，`Err(e)`分支会捕捉错误信息并打印出来，便于后续调试分析。

### 10.14函数名: `read_rar_markdown`

#### 使用方法

**描述**:  从rar中读取md文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的md文件的路径

**返回值**:  

成功：`UnrarResult<String, Box<dyn UnrarError>>`: 成功时返回一个字符串，字符串中包含指定md文件全部内容，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_markdown("src/test_examples/test_rar.rar","test_rar\\test_md.md");
match res {
    Ok(content) => println!("rar文件中指定md文件的内容: \n {}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

使用`FileContentReader::FileReader`尝试读取`rar`文件中特定`md`文件内容。调用`read_rar_markdown`方法，传入rar路径和md文件名。成功则输出内容，失败打印错误信息。此流程实现从压缩文件中准确读取并展示文本数据。

### 10.15函数名: `read_rar_md_by_line`

#### 使用方法

**描述**:  按行读取md文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的md文件的路径

**返回值**:  

成功： `UnrarResult<Vec<String>, Box<dyn UnrarError>>`: 成功时返回一个字符串数组，每个字符串中包含指定md文件的内容，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_md_by_line("src/test_examples/test_rar.rar","test_rar\\test_md.md");
match res {
    Ok(content) => println!("rar文件中指定md文件的内容: \n 		{:?}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

运用`FileContentReader::FileReader`按行读取`rar`包中特定`md`文件：

调用`read_rar_md_by_line`方法，参数包括rar文件路径及md文件名。结果匹配：成功则打印内容，失败输出错误详情。此流程实现了逐行读取压缩文件内文本数据的功能。

### 10.16函数名: `read_rar_md_by_byte`

#### 使用方法

**描述**:  按字节读取md文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的md文件的路径

**返回值**:  

成功：`UnrarResult<Vec<u8>, Box<dyn UnrarError>>`: 成功时返回一个u8字节数组，包含指定md文件全部内容，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_md_by_byte("src/test_examples/test_rar.rar","test_rar\\test_md.md");
match res {
    Ok(content) => println!("rar文件中指定md文件的内容: \n 		{:?}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

利用`FileContentReader::FileReader`按字节读取`rar`档案里指定的`md`文件：启动`read_rar_md_by_byte`方法，输入目标rar与md文件路径。处理结果：若成功，显示文件内容；若失败，呈现错误信息。此操作有效支持了对压缩文档中文本的字节级读取。

### 10.17函数名: `read_rar_md_by_block`

#### 使用方法

**描述**:  按块读取md文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的md文件的路径
	`block_size:<usize>`: 每次读取的块大小，以字节为单位

**返回值**:  

成功：`UnrarResult<Vec<String>, Box<dyn UnrarError>>`: 成功时返回指定Markdown文件内容的字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_md_by_block("src/test_examples/test_rar.rar","test_rar\\test_md.md",4);
match res {
    Ok(content) => println!("rar文件中指定md文件的内容: \n {:?}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

通过`FileContentReader::FileReader`按块(大小为4)读取`rar`中的`md`文件。调用`read_rar_md_by_block`，参数含rar、md路径及块尺寸。结果：成功则展现内容，失败则暴露错误。实现压缩文档文本的分区读取功能。

### 10.18函数名: `read_rar_excel`

#### 使用方法

**描述**:  从rar中读取excel文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的excel文件的路径

**返回值**:  

成功：`UnrarResult<Vec<String>, Box<dyn UnrarError>>`: 成功时返回指定excel文件内容的字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_excel("src/test_examples/test_rar.rar","test_rar\\test_excel.xlsx");
match res {
    Ok(content) => println!("rar文件中指定excel文件的内容: \n 	{:?}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

使用`FileContentReader::FileReader`提取`rar`中`excel`文件内容：调用`read_rar_excel`函数，传入rar及excel完整路径。结果显示：正确，则展示表格数据；错误，则反馈问题细节。这一过程实现了从压缩包直接获取Excel信息。

### 10.19函数名: `read_rar_pdf_as_string`

#### 使用方法

**描述**:  从rar中读取pdf文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的pdf文件的路径

**返回值**:  

成功：`UnrarResult<String, Box<dyn UnrarError>>`: 成功时返回指定pdf文件内容的字符串，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_pdf_as_string("src/test_examples/test_rar.rar","test_rar\\test_pdf.pdf");
match res {
    Ok(content) => println!("rar文件中指定pdf文件的内容: \n 		{}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

运用`FileContentReader::FileReader`读取`rar`中`pdf`文件为字符串：执行`read_rar_pdf_as_string`方法，输入rar及其内部pdf路径。成效：如无误，打印pdf内容；若有差池，报错说明。此举达成从压缩包获取PDF文本的目的。

### 10.20函数名: `read_rar_pptx_text`

#### 使用方法

**描述**:  从rar中读取ppt文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的ppt文件的路径

**返回值**:  

成功： `UnrarResult<String, Box<dyn UnrarError>>`: 成功时返回指定ppt文件内容的字符串，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_pptx_text("src/test_examples/test_rar.rar","test_rar\\test_ppt.pptx");
match res {
    Ok(content) => println!("rar文件中指定ppt文件的内容: \n {}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

通过`FileContentReader::FileReader`提取`rar`内`pptx`文本内容：调用`read_rar_pptx_text`函数, 输入rar和pptx文件路径。结果：成功读取，输出pptx文本；读取失败，显示错误信息。此操作实现从rar中直接读取PowerPoint文本。

### 10.21函数名: `read_rar_pptx_text_by_slide`

#### 使用方法

**描述**:  按行读取rar中ppt文件内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的pptx文件的路径

**返回值**:  

成功：`UnrarResult<Vec<String>, Box<dyn UnrarError>>`: 成功时返回指定pptx文件中提取的所有幻灯片文本内容，每一页一个向量，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_rar_pptx_text_by_slide("src/test_examples/test_rar.rar","test_rar\\test_ppt.pptx");
match res {
    Ok(content) => println!("rar文件中指定ppt文件的内容: \n 		{:?}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

借助`FileContentReader::FileReader`逐幻灯片读取`rar`内`pptx`内容：调用`read_rar_pptx_text_by_slide`，参数包含rar与pptx文件位置。效果：成功返回各页幻灯片文字；失败抛出异常详情。该步骤实现对PPTX文件分页读取的功能。

### 10.22函数名: `read_ppt_notes_from_rar`

#### 使用方法

**描述**:  按页读取rar中ppt文件备注内容

**参数**:  
	`rar_path:<&str>`: RAR 文件的路径
	`file_name:<&str>`: 要打开的pptx文件的路径

**返回值**:  

成功：`UnrarResult<Vec<String>, Box<dyn UnrarError>>`: 成功时返回指定ppt文件备注的字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_ppt_notes_from_rar("src/test_examples/test_rar.rar","test_rar\\test_ppt.pptx");
match res {
    Ok(content) => println!("rar文件中指定ppt文件的内容: \n {:?}", content),
    Err(e) => println!("读取rar文件失败: {}", e), 
}
```

#### 集成流程

借助`FileContentReader::FileReader`逐幻灯片读取`rar`内`pptx`内容：调用`read_rar_pptx_text_by_slide`，参数包含rar与pptx文件位置。效果：成功返回各页幻灯片文字；失败抛出异常详情。该步骤实现对PPTX文件分页读取的功能。

## 11.读取tar文件

### 11.1函数名: `list_tar_filenames`

#### 使用方法

**描述**:  列出文件目录

**参数**:  
	`file_path:<P: AsRef<Path>>`: tar文件路径
	`exclude_directories:<bool>`: 是否包含压缩包里的文件目录

**返回值**:  

成功：`Result<Vec<String>>`: 成功时返回包含tar所有文件目录的字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::list_tar_filenames("src/test_examples/test_tar.tar");
match res {
    Ok(content) => println!("tar文件中所有文件目录: \n {:?}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

使用`FileContentReader::FileReader`列出`tar`文件中全部文件名：调用`list_tar_filenames`方法处理tar文件路径。成果：成功获取，打印所有文件列表；出现错误，输出失败原因。这一步骤实现了遍历并获取tar包内文件名称的需求。

### 11.2函数名: `read_tar_text`

#### 使用方法

**描述**:  直接读取txt文件内容

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的文本文件的路径

**返回值**:  

成功：`Result<String>`: 成功时返回包含指定的tar文本文件内容的字符串，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_text("src/test_examples/test_tar.tar","test_txt.txt");
match res {
    Ok(content) => println!("tar文件中指定文本文件的内容: \n {}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

运用`FileContentReader::FileReader`模块读取位于`tar`归档内的指定文本文件：发起对`read_tar_text`函数的调用，并传递目标tar文件与内部文本文件的相对路径作为参数。成功情形下，使用`println!`宏输出文件内容；如遇错误，打印出错误描述。这种做法能够有效地从复杂压缩包中提取并展示纯文本信息

### 11.3函数名: `read_tar_text_by_line`

#### 使用方法

**描述**:  按行读取txt文件内容

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的文本文件的路径

**返回值**:  

成功：`Result<Vec<String>>`: 成功时返回包含指定的tar文本文件内容的字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_text_by_line("src/test_examples/test_tar.tar","test_txt.txt");
match res {
    Ok(content) => println!("tar文件中指定文本文件的内容: \n {:?}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

通过`FileContentReader::FileReader`按行读取`tar`档案里的特指文本文件：调用`read_tar_text_by_line`方法，输入`tar`文件及其内文本文件的位置。成功执行，逐行打印文本内容；遇到问题，反馈读取错误。这种方式适用于需逐行处理文本文件的场景，增强了数据处理的灵活性。

### 11.4函数名: `read_tar_txt_by_byte`

#### 使用方法

**描述**:  按字节读取文本文件内容

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的文本文件的路径

**返回值**:  

成功：`Result<Vec<u8>>`: 成功时返回包含指定的tar文本文件内容的字节数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_txt_by_byte("src/test_examples/test_tar.tar","test_txt.txt");
match res {
    Ok(content) => println!("tar文件中指定文本文件的内容: \n {:?}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

借助`FileContentReader::FileReader`按字节读取`tar`文件中特定文本：尝试运行`read_tar_txt_by_byte`功能，指定`tar`和文本文件路径。成功时，按字节形式展现文本内容；失败则呈现读取过程中所遇错误。种方法适用于需要精确实时控制每个字符的应用场景。

### 11.5函数名: `read_tar_txt_by_block`

#### 使用方法

**描述**:  按块读取txt文本文件内容

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的文本文件的路径
	`block_size:<usize>`: 每次读取的块大小，以字节为单位

**返回值**:  

成功：`Result<Vec<String>>`: 成功时返回一个包含每个块的向量，每个块都是一个字符串，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_txt_by_block("src/test_examples/test_tar.tar","test_txt.txt",4);
match res {
    Ok(content) => println!("tar文件中指定文本文件的内容: \n {:?}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

利用`FileContentReader::FileReader`按块读取`tar`中特定文本文件：执行`read_tar_txt_by_block`，传入`tar`文件名，文本文件名及块大小。若无异常，按指定大小的块输出文本；若出错，显示读取失败信息。这种方式适用于处理大型文本文件，提高读取效率。

### 11.6函数名: `read_tar_csv_by_line`

#### 使用方法

**描述**:  按行读取csv文件

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的csv文件的路径

**返回值**:  

成功：`Result<Vec<Vec<String>>>`: 成功时返回一个二维字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_csv_by_line("src/test_examples/test_tar.tar","test_csv.csv");
match res {
    Ok(content) => println!("tar文件中csv文件的内容: \n {:?}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

采用`FileContentReader::FileReader`按行读取`tar`归档内的`csv`文件：尝试调用`read_tar_csv_by_line`函数，参数为`tar`文件路径和`csv`文件名。成功时，逐行输出`csv`内容；失败则打印读取错误。此方法适用于需要逐行处理`csv`数据的场景。

### 11.7函数名: `read_tar_csv_by_column`

#### 使用方法

**描述**:  按列读取csv文件

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的csv文件的路径

**返回值**:  

成功：`Result<Vec<Vec<String>>>`: 成功时返回一个二维字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_csv_by_column("src/test_examples/test_tar.tar","test_csv.csv");
match res {
    Ok(content) => println!("tar文件中csv文件的内容: \n {:?}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

运用`FileContentReader::FileReader`从`tar`包中的`csv`抽取列数据：启动`read_tar_csv_by_column`进程，目标为`tar`与内部`csv`。无误，则按列格式展示`csv`信息；出现差池，即刻回传读取障碍详情。该方案针对需快速获取`csv`各列数据的需求有效。

### 11.8函数名: `read_tar_csv_by_block`

#### 使用方法

**描述**:  按块读取csv文件

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的csv文件的路径
	`block_size:<usize>`: 每次读取的块大小，以字节为单位

**返回值**:  

成功：`Result<Vec<Vec<Vec<String>>>>`: 成功时返回一个向量，每个向量元素即为csv文件块的内容，用二维向量存储，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_csv_by_block("src/test_examples/test_tar.tar","test_csv.csv",4);
match res {
    Ok(content) => println!("tar文件中csv文件的内容: \n {:?}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

应用`FileContentReader::FileReader`按块读取`tar`里`csv`文件：调用`read_tar_csv_by_block`，传入`tar`路径，`csv`名称及块尺寸。若读取正常，依据设定块大小输出`csv`内容；若有错误，反馈读取失败细节。这种方法适合高效处理大数据量的`csv`文件

### 11.9函数名: `read_tar_json`

#### 使用方法

**描述**:  读取json文件内容

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的json文件的路径

**返回值**:  

成功：`Result<Value>`: 成功时返回Value，Value包含整个json文件的内容，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_json("src/test_examples/test_tar.tar","test_json.json");
match res {
    Ok(content) => println!("tar文件中json文件的内容: \n {}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

使用`FileContentReader::FileReader`读取`tar`中的`json`文件：执行`read_tar_json`，参数包括`tar`文件路径、`json`文件名。读取无误，输出`json`内容；若出错，显示读取失败信息。这种方式直接且有效，适用于`json`数据的读取。

### 11.10函数名: `read_tar_jsonl_by_line`

#### 使用方法

**描述**:  按行读取jsonl文件内容

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的jsonl文件的路径

**返回值**:  

成功：`Result<Vec<Value>>`: 成功时返回Value数组，Value数组包含整个jsonl文件的内容，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_jsonl_by_line("src/test_examples/test_tar.tar","test_jsonline.jsonl");
match res {
    Ok(content) => println!("tar文件中jsonl文件的内容: \n {:?}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

利用`FileContentReader::FileReader`按行读取`tar`里的`jsonl`文件：尝试运行`read_tar_jsonl_by_line`，指定`tar`档案与`jsonl`文件位置。如操作成功，将以行为单位展现`jsonl`数据；遇到问题，则输出读取失误的具体原因。此法适用于处理每行都是独立JSON对象的`jsonl`文件。

### 11.11函数名: `read_tar_xml_text`

#### 使用方法

**描述**:  直接读取xml文件内容

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的xml文件的路径

**返回值**:  

成功：`Result<String>`: 成功时返回一个字符串，字符串中包含指定xml文件全部内容，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_xml_text("src/test_examples/test_tar.tar","test_xml.xml");
match res {
    Ok(content) => println!("tar文件中xml文件的内容: \n {}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

通过`FileContentReader::FileReader`提取`tar`中`xml`文件的文本内容：调用`read_tar_xml_text`方法，输入`tar`文件及`xml`文件名。成功读取，输出`xml`文本信息；读取错误，显示失败原因。此流程适用于直接获取`xml`文件的文本数据。

### 11.12函数名: `list_tar_filenames`

#### 使用方法

**描述**:  按照事件读取xml文件内容

**参数**:  
	`tar_path:<&str>`: 文件路径
	`file_name:<&str>`: 要打开的xml文件的路径
	`on_start:<FnMut(&str)>`: 处理Start事件的函数
	`on_text:<FnMut(&str)>`: 处理Text事件的函数
	`on_end:<FnMut(&str)>`: 处理End事件的函数

**返回值**:  

成功：`Result<()>`：无返回值

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
// 读取xml文件标签
let mut start_tags:Vec<String> = Vec::new();
let mut end_tags:Vec<String> = Vec::new();
let mut text:Vec<String> = Vec::new();
// 处理标签的闭包
let on_start = |tag_name:&str|{
    start_tags.push(tag_name.to_string());
};
let on_end = |tag_name:&str| {
    end_tags.push(tag_name.to_string());
};
let on_text = |text_content:&str| {
    text.push(text_content.to_string());
};
let res = FileReader::read_tar_xml_by_listener("src/test_examples/test_tar.tar","test_xml.xml", on_start, on_text, on_end);
match res {
    Ok(()) => {
        println!("Start tags:");
        for start in start_tags {
            println!("  {}", start);
        }
        println!("Text nodes:");
        for text in text {
            println!("  {}", text);
        }

        println!("end tags:");
        for end in end_tags {
            println!("  {}", end);
        }
    },
    Err(e) => eprintln!("Error processing XML: {}", e),
}
```

#### 集成流程

采用`FileContentReader::FileReader`监听`tar`内`xml`文件的标签和文本节点：定义存储开始标签、结束标签和文本的向量。设置处理标签的函数，分别收集开始、结束标签以及文本内容。执行`read_tar_xml_by_listener`，参数含`tar`路径、`xml`名称及上述处理函数。读取过程顺利，遍历并打印所有开始标签、文本节点和结束标签；发生错误，输出XML处理异常信息。这一流程特别适用于分析和处理复杂`xml`结构的数据。

### 11.13函数名: `read_tar_markdown`

#### 使用方法

**描述**:  直接读取md文件内容

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的md文件的路径

**返回值**:  

成功： `Result<String>`: 成功时返回一个字符串，字符串中包含指定md文件全部内容，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_markdown("src/test_examples/test_tar.tar","test_md.md");
match res {
    Ok(content) => println!("tar文件中md文件的内容: \n {}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

运用`FileContentReader::FileReader`读取`tar`内的`markdown`文件：尝试调用`read_tar_markdown`方法，并给出`tar`文件与`markdown`文件的位置。读取成功后，打印`markdown`内容；如果出现错误，展示读取失败的信息。这个步骤对查看或预览压缩包内的`markdown`文档尤其有用。

### 11.14函数名: `read_tar_md_by_line`

#### 使用方法

**描述**:  按行读取md文件内容

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的md文件的路径

**返回值**:  

成功：`Result<Vec<String>>`: 成功时返回一个字符串数组，每个字符串中包含指定md文件的内容，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_md_by_line("src/test_examples/test_tar.tar","test_md.md");
match res {
    Ok(content) => println!("tar文件中md文件的内容: \n {:?}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

通过`FileContentReader::FileReader`按行读取`tar`中的`markdown`文件：执行`read_tar_md_by_line`，指定`tar`文件路径及`markdown`文件名。读取无误，逐行输出`markdown`内容；若出错，显示读取失败消息。这种方式适用于需要逐行处理或分析`markdown`文件的场景。

### 11.15函数名: `read_tar_md_by_byte`

#### 使用方法

**描述**:  按字节读取 md文件

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的md文件的路径

**返回值**:  

成功：`Result<Vec<u8>>`: 成功时返回一个u8字节数组，包含指定md文件全部内容，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_md_by_byte("src/test_examples/test_tar.tar","test_md.md");
match res {
    Ok(content) => println!("tar文件中md文件的内容: \n {:?}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

利用`FileContentReader::FileReader`按字节读取`tar`里`markdown`文件：调用`read_tar_md_by_byte`方法，传入`tar`文件及`markdown`文件的路径。读取成功，打印字节流形式的`markdown`内容；读取错误，输出失败详情。这种方法适合底层处理或特殊数据解析需求

### 11.16函数名: `read_tar_md_by_block`

#### 使用方法

**描述**:  按块读取md文件内容

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的md文件的路径
	`block_size:<usize>`: 每次读取的块大小，以字节为单位

**返回值**:  

成功：`Result<Vec<String>>`: 成功时返回指定Markdown文件内容的字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_md_by_block("src/test_examples/test_tar.tar","test_md.md",4);
match res {
    Ok(content) => println!("tar文件中md文件的内容: \n {:?}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

使用`FileContentReader::FileReader`按固定块大小读取`tar`中的`markdown`：发起`read_tar_md_by_block`请求，参数包含`tar`文件位置、`markdown`文件标识与块大小。读取操作成功，展示分块后的`markdown`内容；如遇错误，反馈读取`tar`文件失败的具体情况。这种策略适用于高效处理大型文件或实现自定义数据流管理。

### 11.17函数名: `read_tar_excel`

#### 使用方法

**描述**:  读取整个excel文件内容

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的excel文件的路径

**返回值**:  

成功：`Result<Vec<String>>`: 成功时返回指定excel文件内容的字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_excel("src/test_examples/test_tar.tar","test_excel.xlsx");
match res {
    Ok(content) => println!("tar文件中excel文件的内容: \n {:?}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

应用`FileContentReader::FileReader`读取`tar`内`excel`文件：尝试`read_tar_excel`，参数为`tar`和`excel`文件路径。成功读取，输出`excel`文件内容；读取失败，显示错误信息。此操作便于预览或提取压缩包中的`excel`数据。

### 11.18函数名: `read_tar_pdf_as_string`

#### 使用方法

**描述**:  读取pdf文件内容

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的pdf文件的路径

**返回值**:  

成功：`Result<String>`: 成功时返回指定pdf文件内容的字符串，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_pdf_as_string("src/test_examples/test_tar.tar","test_pdf.pdf");
match res {
    Ok(content) => println!("tar文件中pdf文件的内容: \n {}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

借助`FileContentReader::FileReader`将`tar`里的`pdf`文件转换为字符串：执行`read_tar_pdf_as_string`，输入`tar`和`pdf`文件名。若读取成功，则以文本形式呈现`pdf`内容；若失败，则报错说明读取`tar`文件过程中遇到的问题。这一过程有助于进一步文本分析或信息抽取。

### 11.19函数名: `read_tar_pptx_text_by_slide`

#### 使用方法

**描述**:  按行读取ppt文件内容

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的ppt文件的路径

**返回值**:  

成功：`Result<Vec<String>>`: 成功时返回指定pptx文件中提取的所有幻灯片文本内容，每一页一个向量，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_pptx_text_by_slide("src/test_examples/test_tar.tar","test_ppt.pptx");
match res {
    Ok(content) => println!("tar文件中ppt文件的内容: \n {:?}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

运用`FileContentReader::FileReader`从`tar`内`pptx`文件逐张幻灯片读取文本：调用`read_tar_pptx_text_by_slide`函数，给出`tar`文件和`pptx`文件名称。成功读取后，按幻灯片顺序列出所有文本内容；出现错误，提示无法读取`tar`文件相关详情。该功能利于自动化处理演示文稿中的文字信息。

### 11.20函数名: `read_tar_pptx_notes`

#### 使用方法

**描述**:  读取ppt备注信息

**参数**:  
	`tar_path:<P: AsRef<Path>>`: tar文件路径
	`file_name:<&str>`: 要打开的ppt文件的路径

**返回值**:  

成功：`Result<Vec<String>>`: 成功时返回指定ppt文件备注的字符串数组，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_tar_pptx_notes("src/test_examples/test_tar.tar","test_ppt.pptx");
match res {
    Ok(content) => println!("tar文件中ppt文件的内容: \n {:?}", content),
    Err(e) => println!("读取tar文件失败: {}", e), 
}
```

#### 集成流程

采用`FileContentReader::FileReader`获取`tar`中`pptx`备注信息：通过`read_tar_pptx_notes`指定`tar`及`pptx`文件路径。读取无误，展示每页备注内容；发生异常，告知`tar`文件读取失败原因。这项特性方便收集和审查PPT演讲者备注。

## 12.读取文件信息

### 12.1函数名: `read_file_default`

#### 使用方法

**描述**:  会自动判断文件格式来读取内容

**参数**:  `file_path:<&str>` : 文件的路径

**返回值**: 

成功： `Result<Vec<Vec<String>>>` : 成功时返回文件的内容，失败时返回错误信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::read_file_default("src/test_examples/test_txt.txt");
match res {
    Ok(content) => println!("文件内容: \n {:?}", content),
    Err(e) => println!("读取文件失败: {}", e), 
}
```

#### 集成流程

首先，获取文件路径与扩展名。然后，根据扩展名选择处理策略：

- TXT: 直接读取内容，封装。
- CSV: 按列读取，整合。
- JSON, XML, MD: 读取文本，单独封装。
- XLS, XLSX: 按工作表读取，整合。
- PPT, PPTX: 按幻灯片读取文本，整合。
- 其他类型：返回空结果。

经过处理，内容统一组织输出，适配不同文件类型。



### 12.2函数名: `get_file_size`

#### 使用方法

**描述**:  获取文件大小，单位字节

**参数**:  `file_path:<AsRef<Path>>`: 文件的路径

**返回值**:  

成功：`Result<u64>`: 返回文件的大小

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::get_file_size("src/test_examples/test_txt.txt");
match res {
    Ok(size) => println!("文件大小: \n {}", size),
    Err(e) => println!("读取文件失败: {}", e), 
}
```

#### 集成流程

调用`get_file_metadata`方法以获取文件的元数据信息，从返回的元数据中提取文件大小信息，最终返回文件大小作为`u64`类型的结果。



### 12.3函数名: `get_file_created_time`

#### 使用方法

**描述**:  获取文件创建的时间

**参数**:  `file_path:<AsRef<Path>>`: 文件的路径

**返回值**:  

成功：`Result<String>`: 返回文件的创建时间的字符串

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::get_file_created_time("src/test_examples/test_txt.txt");
match res {
    Ok(content) => println!("文件创建时间: \n {}", content),
    Err(e) => println!("读取文件失败: {}", e), 
}
```

#### 集成流程

调用`get_file_metadata`方法获取文件的元数据，从返回的元数据中提取创建时间信息，将创建时间转换为本地时区的`DateTime，`格式化`DateTime`为"年-月-日 时:分:秒"的字符串格式，最终返回格式化后的创建时间字符串。



### 12.4函数名: `get_last_accessed_time`

#### 使用方法

**描述**:  获取上一次访问的时间

**参数**:  `file_path:<AsRef<Path>>`: 文件的路径

**返回值**:  

成功：`Result<String>`: 返回文件的上一次访问时间的字符串

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::get_last_accessed_time("src/test_examples/test_txt.txt");
match res {
    Ok(content) => println!("文件的上一次访问时间: \n {}", content),
    Err(e) => println!("读取文件失败: {}", e), 
}
```

#### 集成流程

首先，通过`get_file_metadata`方法获取目标文件的元数据，从获取到的元数据中，读取最后访问时间信息，将最后访问时间转换为本地时区的`DateTime`格式，将转换后的`DateTime`格式化为"年-月-日 时:分:秒"的字符串形式，最后，返回格式化后的最后访问时间字符串。



### 12.5函数名: `get_last_modified`

#### 使用方法

**描述**:  获取文件最后修改时间

**参数**:  `file_path:<AsRef<Path>>`: 文件的路径

**返回值**:  

成功：`Result<String>`: 返回文件最后修改时间的字符串

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::get_last_modified("src/test_examples/test_txt.txt");
match res {
    Ok(content) => println!("文件的最后修改时间: \n {}", content),
    Err(e) => println!("读取文件失败: {}", e), 
}
```

#### 集成流程

调用`get_file_metadata`方法以获取文件的元数据，从元数据中读取最后修改时间，将最后修改时间转换为本地时区的`DateTime`格式，将`DateTime`格式化为"年-月-日 时:分:秒"的字符串格式，返回格式化后的最后修改时间字符串。



### 12.6函数名: `is_directory`

#### 使用方法

**描述**:  获取文件是否为目录

**参数**:  `file_path:<AsRef<Path>>`: 文件的路径

**返回值**:  

成功：`Result<bool>`: 返回bool值,true表示是目录

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::is_directory("src/test_examples/test_txt.txt");
match res {
    Ok(content) => println!("文件是否为目录: \n {}", content),
    Err(e) => println!("读取文件失败: {}", e), 
}
```

#### 集成流程

通过`get_file_metadata`方法获取文件路径对应的元数据，直接从元数据中判断该路径是否指向一个目录，返回一个布尔值，`true`表示是目录，`false`表示不是目录。



### 12.7函数名: `is_regular_file`

#### 使用方法

**描述**:  获取文件是否为普通文件

**参数**:  `file_path:<AsRef<Path>>`: 文件的路径

**返回值**:  

成功：`Result<bool>`: 返回bool值,true表示是普通文件

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::is_regular_file("src/test_examples/test_txt.txt");
match res {
    Ok(content) => println!("文件是否为普通文件: \n {}", content),
    Err(e) => println!("读取文件失败: {}", e), 
}
```

#### 集成流程

使用`get_file_metadata`方法获取指定路径的文件元数据，从元数据中检查是否为常规文件，返回结果：`true`表示是常规文件，`false`则表示不是。



### 12.8函数名: `parse_permissions`

#### 使用方法

**描述**:  解析文件权限位并返回一个表示权限的字符串

**参数**:  `attrs:<u32>`: 是一个 u32 类型的整数，表示文件的权限位

**返回值**:  

成功：`String`:返回一个字符串，表示文件的权限，格式为 "rwxrwxrwx"，其中每个字符代表读（r）、写（w）和执行（x）权限

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let permissions = FileReader::parse_permissions(0o755);
println!("文件权限: \n {}", permissions);
```

#### 集成流程

从文件属性中解析权限位，使用位运算判断每个权限（读、写、执行）是否被设置，对所有者（owner）、用户组（group）、其他用户（other）分别检查读、写、执行权限，使用格式化字符串构造权限表示，其中"r"代表读权限，"w"代表写权限，"x"代表执行权限，"-"表示无权限，返回格式化后的权限字符串，格式如下："读写执行-读写执行-读写执行"，每组之间的"-"表示该组的权限到此结束。



### 12.9函数名: `get_file_permission`

#### 使用方法

**描述**:  获取文件权限

**参数**:  `file_path:<AsRef<Path>>`: 文件的路径

**返回值**:  

成功：`Result<String>`: 返回表示文件权限的字符串

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::get_file_permission("src/test_examples/test_txt.txt");
match res {
    Ok(content) => println!("文件权限: \n {}", content),
    Err(e) => println!("读取文件失败: {}", e), 
}
```

#### 集成流程

调用`get_file_metadata`方法获取目标文件的元数据，从元数据中提取权限信息，检查文件是否被设置为只读：若为`true`，则表示文件为只读，返回权限字符串"r--"，若为`false`，则文件可写，返回权限字符串"rw-"。



### 12.10函数名: `get_file_extension`

#### 使用方法

**描述**:  获取文件扩展名

**参数**:  `file_path:<AsRef<Path>>`: 文件的路径

**返回值**:  

成功：`String`: 返回文件扩展名

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::get_file_extension("src/test_examples/test_txt.txt");
println!("文件扩展名: \n {}", res);
```

#### 集成流程

接收一个可以转换为`Path`的参数`file_path，`调用`as_ref().extension()`获取文件的扩展名部分，使用`and_then(|ext| ext.to_str())`尝试将扩展名转换为字符串，这一步可能成功也可能失败（如遇到无效的UTF-8），若转换成功，则直接使用；若失败或扩展名不存在，则使用`unwrap_or("unknown")`提供默认值"unknown"，最终返回扩展名的字符串表示。



### 12.11函数名: `get_file_metadata`

#### 使用方法

**描述**:  读取文件的基本属性信息

**参数**:   `file_path:<AsRef<Path>>`: 文件的路径

**返回值**:  

成功：`Result<Metadata>`: 返回文件的基本属性信息

失败：文件路径错误，文件类型错误， 无法打开文件

```rust
use FileContentReader::FileReader;
let res = FileReader::get_file_metadata("src/test_examples/test_txt.txt");
match res {
    Ok(content) => println!("文件基本属性信息: \n {:?}", content),
    Err(e) => println!("读取文件失败: {}", e), 
}
```

#### 集成流程

接收文件路径处理，调用`fs::metadata`获取文件元数据。返回元数据或错误信息。