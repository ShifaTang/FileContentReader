#                                                                                                                                                                                                                                                                                                                                功能说明文档

## 一：读取TXT文本文件

- [x] 读取TXT小文件内容
- [x] 按行读取TXT文件内容
- [x] 按字节读取TXT文件内容
- [x] 按块读取TXT文件内容

### 1： 读取TXT小文件内容

```rust
    pub fn read_txt(file_path: &str) -> Result<String> {
        assert!(fs::metadata(file_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(file_path.ends_with(".txt"), "文件类型错误,请检查文件类型是否为txt文件");

        let file = File::open(file_path)?;
        let mut reader = BufReader::new(file); // 缓冲器
        let mut content = String::new();
        reader.read_to_string(&mut content)?;
        Ok(content)
    }
```

**核心功能**：输入文件路径，创建缓冲读取器，将文件内容读取到字符串中，并将文件内容返回

**特性**：适合小文件读取；BufReader管理内部缓冲区，提高读取效率，有效管理内存资源

### 2：按行读取TXT文件内容

```rust
    pub fn read_txt_by_line<P: AsRef<Path>>(file_path: P) -> Result<Vec<String>> {
        let file = File::open(file_path)?;
        let mut reader = BufReader::new(file);
        let mut lines = Vec::new();
        loop {
            let mut line = String::new();
            match reader.read_line(&mut line) {
                Ok(0) => break, // 0 表示读到的字节数，0，表示读到文件末尾
                Ok(_) => lines.push(line.trim_end_matches('\n').to_string()), // 正常读取
                Err(e) => return Err(e), // 读取错误
            }
        }
        Ok(lines)
    }
```

**核心功能：** 输入文件路径，创建缓冲区，无限循环，按行读取文件内容，每一行内容作为一个字符串，返回字符串向量

**特性：** 实现特质`AsRef<Path>`，增加了代码的灵活性和重用性；创建内存缓冲区，高效读取；去除每一行的换行符，正常读取文件每行内容

### 3：按字节读取TXT文件内容

```rust
    pub fn read_txt_by_byte<P: AsRef<Path>>(file_path: P) -> Result<Vec<u8>> {
        let file = File::open(file_path)?;
        let mut reader = BufReader::new(file);
        let mut buffer = [0u8;1]; // 默认值0，类型u8，数组大小1
        let mut bytes = Vec::new();
        loop {
            match reader.read(&mut buffer) {
                Ok(0) => break,
                Ok(n) => {
                    if n == 1 {
                        bytes.push(buffer[0]);
                    } else {
                        bytes.extend_from_slice(&mut buffer[..n]);  // 这里是根据函数本身返回值需要
                    }
                },
                Err(e) => return Err(e),
            }
        }
        Ok(bytes)
    }
```

**核心功能：**输入文件路径，创建缓冲区和缓冲字节数组，按字节读取文件内容，返回字节向量

**特性：**使用 `AsRef<Path>`，函数可以接受多种类型的路径表示形式；通过 `Vec::new()` 动态管理内存，避免了不必要的内存分配和释放；通过 `extend_from_slice` 方法高效地将数据添加到向量中；通过 `BufReader` 提高了读取效率，减少了系统调用次数

### 4：按块读取TXT文件内容

```rust
    pub fn read_txt_by_block(file_path: &str, block_size: usize) -> Result<Vec<String>> {
        let file = File::open(file_path).expect(FILE_OPEN_FAILED);
        let mut reader = BufReader::new(file);
        let mut blocks = Vec::new();
        let mut buffer = vec![0; block_size]; //创建一个包含block_size个0元素的向量。
        loop {
            let bytes_read = reader.read(&mut buffer)?; // 一次性读取buffer大小字节，不够，读取剩下的
            if bytes_read == 0 {
                break; // 读取到文件末尾
            }
            // 将读取的字节转换为字符串并添加到块中
            blocks.push(String::from_utf8_lossy(&buffer[..bytes_read]).to_string());
        }
        Ok(blocks)
    }
```

**核心功能：**输入文件路径，文件块大小，按块读取文件内容，将读取的每个块分别转换为字符串，返回字符串向量

**特性：**`block_size` 允许用户指定读取的块大小，提高了函数的灵活性；用户可以根据文件大小和性能需求来选择合适的块大小；`vec![0; block_size]`提前分配所需的空间，提高性能；读取数据到缓冲区 `buffer` 中，提高读取效率；`String::from_utf8_lossy`确保字节序列正确转换为字符串

## 二：读取CSV文件

- [x] 按行读取csv文件内容
- [x] 按列读取csv文件内容
- [x] 按块读取CSV文件内容

### 1：按行读取csv文件内容

```rust
    pub fn read_csv_by_line(file_path: &str) -> io::Result<Vec<Vec<String>>> {
        assert!(fs::metadata(file_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(file_path.ends_with(".csv"), "文件类型错误,请检查文件类型是否为csv文件");
        let file = File::open(file_path)?;
        let mut rdr = ReaderBuilder::new().from_reader(file);
        let records = Arc::new(Mutex::new(Vec::new()));
        rdr.records()
            .par_bridge() // Convert the iterator to a parallel iterator
            .for_each(|result| {
                let record = result.expect("读取记录失败");
                let record_vec: Vec<String> = record.iter().map(|s| s.to_string()).collect();
    
                let mut records = records.lock().expect("获取互斥锁失败");
                records.push(record_vec);
            });
    
        let records = Arc::try_unwrap(records).expect("Arc解包失败").into_inner().expect("Mutex解包失败");
        Ok(records)
    }
```

**核心功能：**输入文件路径，构建 Reader 实例的构造器，允许用户配置 Reader 的行为，创建一个 CSV 读取器。遍历csv文件每一行内容，一行内容的一个数据读取为字符串，文件的一行内容就是一个字符串向量，然后再将每行的内容添加到另一个向量中，最后按行返回csv文件内容

**特性：**通过 `ReaderBuilder` 构造器，可以根据需要配置 CSV 读取器的行为；使用迭代器和闭包特性高效地处理每一行数据；逐行读取 CSV 文件，避免一次性加载整个文件到内存中

### 2：按列读取csv文件内容

```rust
    pub fn read_csv_by_column(file_path: &str) -> Result<Vec<Vec<String>>> {
        let file = File::open(file_path).expect(FILE_OPEN_FAILED);
        let mut rdr = ReaderBuilder::new().from_reader(file);
        // let mut records = Vec::new();  //之前的代码
        let mut records:Vec<Vec<String>> = Vec::new();
        // 读取所有行
        for result in rdr.records() {
            let record = result?;
            records.push(record.iter().map(|s| s.to_string()).collect());
        }
        // println!("temp test records is {:?}", records);
        // 按列转换
        let mut columns = vec![Vec::new(); records[0].len()];
        for record in records {
            for (i, field) in record.into_iter().enumerate() {
                columns[i].push(field);
            }
        }
        Ok(columns)
    }
```

**核心功能：**输入文件路径，构建 Reader 实例的构造器，允许用户配置 Reader 的行为，创建一个 CSV 读取器。按行读取csv文件内容，然后将按行读取到的csv文件内容转换成按列读取的csv文件内容，最后返回按列读取的csv文件内容。每一列文件内容就是一个字符串向量，整个文件内容就是一个向量，里面每一个元素就是一个字符串向量

**特性：**通过 `ReaderBuilder` 构造器，可以根据需要配置 CSV 读取器的行为；使用迭代器和闭包特性高效地处理每一行数据；逐行读取 CSV 文件，将按行读取的文件转换成按列读取，简单高效，避免一次性加载整个文件到内存中

### 3：按块读取CSV文件内容

```rust
    pub fn read_csv_by_block(file_path: &str, block_size: usize) -> Result<Vec<Vec<Vec<String>>>> {
        let file = File::open(file_path).expect(FILE_OPEN_FAILED);
        let mut rdr = ReaderBuilder::new().from_reader(file);
        let mut blocks = Vec::new();
        let mut current_block = Vec::new();

        for result in rdr.records() {
            let record = result.expect("Failed to read record");  // 加了一个expect
            // current_block.push(record.iter().map(|s| s.to_string()).collect());
            let string_vec: Vec<String> = record.iter().map(String::from).collect(); // 一行数据
            current_block.push(string_vec);

            if current_block.len() == block_size { // 满足指定行数，就添加块到结果中
                blocks.push(current_block.clone());
                current_block.clear();
            }
        }
        // 如果最后一个块不满，仍然保存
        if !current_block.is_empty() {
            blocks.push(current_block);
        }

        Ok(blocks)
    }
```

**核心功能：**输入文件路径，块的大小即文件内容行数，构建 Reader 实例的构造器，创建一个 CSV 读取器。按块读取csv文件内容，最后将剩余的文件内容，添加到。每一个块由多行内容组成，数据结构为 `Vec<Vec<String>>`，整个文件由多个块组成

**特性：**通过使用 `&str` 作为文件路径，确保传递的是字符串类型；使用 `expect` 和 `Result` 类型，使得错误处理更加明确和一致；按块处理 CSV 文件，避免一次性加载整个文件到内存中

## 三：读取JSON文件内容

- [x] 一次性读取JSON文件内容
- [x] 动态读取JSON文件内容
- [x] 按块读取JSON文件内容

### 1：一次性读取JSON文件内容

```rust
    pub fn read_json_text(file_path: &str) -> Result<String> {
        let s = Self::read_txt(file_path).unwrap(); // 调用当前结构体read_txt方法读取json文件
        Ok(s)
    }
```

**核心功能：**调用文件读取库中的读取TXT文件内容的方法，一次性将json文件读取到字符串中并返回

**特性：**适合小文件读取；BufReader管理内部缓冲区，提高读取效率，有效管理内存资源

### 2：动态读取JSON文件内容

```rust
    pub fn read_json_dynamic(file_path: &str) -> serde_json::Result<Value> {
        let file = File::open(file_path).expect("文件打开失败");
        let reader = BufReader::new(file);
        // 直接解析为serde_json::Value
        let json_data: Value = serde_json::from_reader(reader)?; // 尝试从 reader 中解析 JSON 数据

        Ok(json_data)
    }
```

**核心功能：**输入文件路径打开文件，创建缓冲区，使用`serde_json::from_reader`方法从缓冲器中直接解析 JSON 数据，最后返回json文件内容

**特性：**通过 `BufReader` 提高了读取效率，减少了系统调用次数；直接从流中解析 JSON 数据，避免了一次性读取整个文件；确保解析后的数据类型为 `serde_json::Value`，提高了代码的安全性和可读性；返回一个 `serde_json::Result<Value>` 类型的结果，明确地处理可能发生的解析错误

### 3：按块读取JSON文件内容

```rust
    pub fn read_json_by_block(file_path: &str, block_size: usize) -> Result<Vec<Vec<Value>>> {
        let file = File::open(file_path).expect(FILE_OPEN_FAILED);
        let mut reader = BufReader::new(file);
        //这里的 <::Value> 指定了我们期望从迭代器中得到的类型是 serde_json::Value。serde_json::Value 是一个枚举类型，
        //它可以代表 JSON 中的任何值（例如对象、数组、字符串等）。rust不认识json，所以反序列化
        // 迭代地解析 JSON 文件，而不是一次性加载整个文件到内存中，这对于处理大文件非常有用。
        // let stream = Deserializer::from_reader(reader).into_iter::<Value>(); // 会一次性读一个数组，不对
        let mut content = String::new();
        reader.read_to_string(&mut content)?;
        let json_array:Value = from_str(&content)?;
        let array = json_array.as_array().ok_or(Error::new(std::io::ErrorKind::Other, "Not an array"))?;

        let mut blocks = Vec::new();
        let mut current_block = Vec::with_capacity(block_size); //创建一个具有预设元素容量 block_size 的向量，元素类型是serde_json::Value
        for value in array {
            current_block.push(value.clone());
            if current_block.len() == block_size {
                blocks.push(current_block);
                current_block = Vec::with_capacity(block_size);
            }
        }
        // 如果最后一个块不满，仍然保存
        if !current_block.is_empty() {
            blocks.push(current_block);
        }

        Ok(blocks)
    }
```

**核心功能：**输入文件路径和块的大小，尝试打开指定文件路径，创建缓冲读取器，读取文件内容到字符串，反序列化整个JSON文件，同时检查JSON文件内容是否为数组，如果是数组则按块分割，分割之后每个块是元素为`Value`的向量，最后判断最后一个块是否符合要求，如果不符合仍然保存。这里的块大小其实就是就是json字典的数量。

**特性：**将字符串内容反序列化为 `serde_json::Value`，确保解析后的数据类型正确；按块处理 JSON 文件，避免一次性加载整个文件到内存中；逐块处理数据，提高了内存使用效率

## 四：读取XML文件

- [x] 直接读取XML文件内容
- [x] 按事件读取XML文件内容

### 1：直接读取XML文件内容

```rust
    pub fn read_xml_text(file_path: &str) -> Result<String> {
        let s = Self::read_txt(file_path)?;
        Ok(s)
    }
```

**核心功能：**输入文件路径，调用文件内容读取库中`read_txt`方法，直接读取XML文件内容，以字符串的形式返回

**特性：**简单直接，通俗易懂

### 2：按事件读取XML文件内容

```rust
pub fn read_xml_by_listener<S, T, E>(
        file_path: &str,
        mut on_start: S,
        mut on_text: T,
        mut on_end: E,
    ) -> Result<()> // 表示可能成功或失败
    where
        S: FnMut(&str), // 可以多次可变调用的闭包
        T: FnMut(&str),
        E: FnMut(&str),
    {
        let file = File::open(file_path).expect(FILE_OPEN_FAILED);
        let reader = BufReader::new(file);
        let mut xml_reader = quick_xml::Reader::from_reader(reader); // 创建一个 XML 读取器，用于从缓冲读取器中读取 XML 数据
        xml_reader.trim_text(true); // 去除文本节点中的空白字符
        let mut buf = Vec::new();
        loop { // 无限循环，直至有break退出
            match xml_reader.read_event_into(&mut buf) { // 读取下一个 XML 事件，并将其存储到 buf 中
                Ok(Event::Start(ref e)) => { // 如果事件是一个开始标签，提取标签名称并调用 on_start 闭包
                    let element_name = String::from_utf8_lossy(e.name().as_ref()).to_string();
                    on_start(&element_name);
                }
                Ok(Event::Text(e)) => { // 如果事件是一个文本节点，解码文本并调用 on_text 闭包
                    let text = e.unescape().unwrap().to_string();
                    on_text(&text); // 可根据需要获取文本节点内容
                }
                Ok(Event::End(ref e)) => { // 如果事件是一个结束标签，提取标签名称并调用 on_end 闭包。
                    let element_name = String::from_utf8_lossy(e.name().as_ref()).to_string();
                    on_end(&element_name);
                }
                Ok(Event::Eof) => break, // 文件结束
                Err(e) => {
                    eprintln!("Error at position {}: {:?}", xml_reader.buffer_position(), e);
                    break;
                }
                _ => {}
            }

            buf.clear(); // 清除缓冲区
        }
        Ok(()) // 如果一切正常，返回一个成功结果。
    }
```

**核心功能：**输入文件路径，三个泛型参数分别代表开始标签、文本节点和结束标签的处理函数。打开文件，创建缓冲读取器，`quick_xml::Reader::from_reader(reader)`创建 XML 读取器，去除空白字符，根据传入的处理函数对XML事件进行解析，返回结果。

**特性：**通过使用泛型参数和生命周期约束，确保了闭包的正确使用；通过 `BufReader` 提高了读取效率，减少了系统调用次数；逐个事件地解析 XML 文件，避免了一次性读取整个文件到内存中；通过闭包传递，可以根据需要定制不同的事件处理逻辑；自动去除文本节点中的空白字符，使得数据更干净

## 五：读取Markdown文件内容

- [x] 一次性读取Markdown文件内容
- [x] 按行读取Markdown文件内容
- [x] 按字节读取Markdown文件内容
- [x] 按块读取Markdown文件内容
- [x] 读取Markdown文件并转换为HTML

### 1：一次性读取Markdown文件内容

```rust
    pub fn read_markdown(file_path: &str) -> Result<String> {
        let file = File::open(file_path).expect(FILE_OPEN_FAILED);
        let mut reader = BufReader::new(file);
        let mut content = String::new();
        reader.read_to_string(&mut content)?;
        Ok(content)
    }
```

**核心功能：**输入文件路径，打开文件，创建缓冲读取器，读取文件内容到字符串，返回结果

**特性：**将整个文件内容读取到字符串中，便于进一步处理；直接返回文件内容，使得接口简洁明了

### 2：按行读取Markdown文件内容

```rust
pub fn read_md_by_line(file_path: &str) -> Result<Vec<String>> {
        assert!(fs::metadata(file_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(file_path.ends_with(".md"), "文件类型错误,请检查文件类型是否为md文件");

        let file = File::open(file_path)?;
        let mut reader = BufReader::new(file);
        let mut lines = Vec::new();

        loop {
            let mut line = String::new();
            match reader.read_line(&mut line) {
                Ok(0) => break, // 0 表示读到的字节数
                Ok(_) => lines.push(line.trim_end_matches('\n').to_string()), // 正常读取
                Err(e) => return Err(e), // 读取错误
            }
        }

        Ok(lines)
    }
```

**核心功能：**输入文件路径，创建缓冲区，无限循环，按行读取文件内容，每一行内容作为一个字符串，返回字符串向量

**特性：** 实现特质`AsRef<Path>`，增加了代码的灵活性和重用性；创建内存缓冲区，高效读取；去除每一行的换行符，正常读取文件每行内容

### 3：按字节读取Markdown文件内容

```rust
    pub fn read_md_by_byte(file_path: &str) -> Result<Vec<u8>> {
        assert!(fs::metadata(file_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(file_path.ends_with(".md"), "文件类型错误,请检查文件类型是否为md文件");

        let file = File::open(file_path)?;
        let mut reader = BufReader::new(file);
        let mut buffer = [0u8;1]; // 默认值0，类型u8，数组大小1
        let mut bytes = Vec::new();
        loop {
            match reader.read(&mut buffer) {
                Ok(0) => break,
                Ok(n) => {
                    if n == 1 {
                        bytes.push(buffer[0]);
                    } else {
                        bytes.extend_from_slice(&mut buffer[..n]);  // 这里是根据函数本身返回值需要
                    }

                },
                Err(e) => return Err(e),
            }
        }

        Ok(bytes)
    }
```

**核心功能：**输入文件路径，创建缓冲区和缓冲字节数组，按字节读取文件内容，返回字节向量

**特性：**使用 `AsRef<Path>`，函数可以接受多种类型的路径表示形式；通过 `Vec::new()` 动态管理内存，避免了不必要的内存分配和释放；通过 `extend_from_slice` 方法高效地将数据添加到向量中；通过 `BufReader` 提高了读取效率，减少了系统调用次数

### 4：按块读取Markdown文件内容

```rust
    pub fn read_md_by_block(file_path: &str, block_size: usize) -> Result<Vec<String>> {
        assert!(fs::metadata(file_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(file_path.ends_with(".md"), "文件类型错误,请检查文件类型是否为md文件");

        let file = File::open(file_path).expect(FILE_OPEN_FAILED);
        let mut reader = BufReader::new(file);
        let mut blocks = Vec::new();
        let mut buffer = vec![0; block_size]; //创建一个包含block_size个0元素的向量。

        loop {
            let bytes_read = reader.read(&mut buffer)?; // 一次性读取buffer大小字节，不够，读取剩下的
            if bytes_read == 0 {
                break; // 读取到文件末尾
            }
            // 将读取的字节转换为字符串并添加到块中
            blocks.push(String::from_utf8_lossy(&buffer[..bytes_read]).to_string());
        }
        Ok(blocks)
    }
```

**核心内容：**输入文件路径，文件块大小，按块读取文件内容，将读取的每个块分别转换为字符串，返回字符串向量

**特性：**`block_size` 允许用户指定读取的块大小，提高了函数的灵活性；用户可以根据文件大小和性能需求来选择合适的块大小；`vec![0; block_size]`提前分配所需的空间，提高性能；读取数据到缓冲区 `buffer` 中，提高读取效率；`String::from_utf8_lossy`确保字节序列正确转换为字符串

### 5：读取Markdown文件并转换为HTML

```rust
    pub fn read_markdown_and_convert_to_html(file_path: &str) -> Result<String> {
        assert!(fs::metadata(file_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(file_path.ends_with(".md"), "文件类型错误,请检查文件类型是否为md文件");

        // 读取Markdown文件内容
        let content = Self::read_markdown(file_path).unwrap();

        // 解析Markdown内容
        let parser = Parser::new(&content);
        let mut html_output = String::new();
        html::push_html(&mut html_output, parser);

        // 返回HTML内容
        Ok(html_output)
    }
```

**核心功能：**输入Markdown文件路径，使用 `Self::read_markdown(file_path).unwrap()` 来读取 Markdown 文件内容，使用 `Parser::new` 创建解析器，并将 Markdown 内容解析为 HTML，使用 `html::push_html` 方法将解析后的 HTML 内容推送到字符串中，返回一个包含转换后的 HTML 内容的字符串

**特性：**使用成熟的 Markdown 解析库，确保了转换的准确性；逐步构建 HTML 字符串，避免了一次性生成大量字符串的开销；直接返回转换后的 HTML 内容，使得接口简洁明了

## 六：读取pdf文件内容

- [x] 读取pdf文件内容

### 1：读取pdf文件内容

```rust
    pub fn read_pdf_as_string(file_path: &str) -> Result<String> {
        let p = pdf_extract::extract_text(file_path);
        match p {
            Ok(s) => {
                Ok(s)
            },
            Err(err) => {
                Err(Error::new(std::io::ErrorKind::Other, err.to_string()))
            }
        }
    }
```

**核心功能：**输入文件路径，调用函数来提取PDF文件中的文本内容，返回字符串结果

**特性：**通过使用 `&str` 作为文件路径，确保传递的是字符串类型；通过调用现有的 PDF 提取函数简化了文件内容提取的逻辑

## 七：读取excel文件内容

- [x] 读取Excel文件中的所有内容，并以字符串形式返回
- [x] 按照Sheet读取Excel文件中的所有内容，并以字符串形式返回
- [x] 按行读取excel文件内容，每一行一个向量，每个元素用制表符分隔
- [x] 按列读取excel文件内容，每一列一个向量，每个元素用制表符分隔
- [x] 按块读取excel文件，并按块格式化为字符串

### 1：读取Excel文件中的所有内容，并以字符串形式返回

```rust
    pub fn read_excel_as_string(file_path: &str) -> Result<String> {
        // 打开Excel文件
        let mut workbook = open_workbook_auto(Path::new(file_path)).unwrap();
        let mut content = String::new();

        // 遍历所有工作表
        for sheet_name in workbook.sheet_names().to_owned() {
            content.push_str(&format!("Sheet: {}\n", sheet_name));

            match workbook.worksheet_range(&sheet_name) {
                Ok(range) => {
                    // 遍历工作表中的每一行
                    for row in range.rows() {
                        let mut row_content = String::new();
                        for cell in row {
                            let cell_content = match cell {
                                Data::String(s) => s.clone(),
                                Data::Float(f) => f.to_string(),
                                Data::Int(i) => i.to_string(),
                                Data::Bool(b) => b.to_string(),
                                // Handle other cell types if necessary
                                _ => "".to_string(),
                            };
                            row_content.push_str(&cell_content);
                            row_content.push('\t'); // Add a tab separator between cells
                        }
                        content.push_str(&row_content);
                        content.push('\n'); // Add a newline after each row
                    }
                },
                Err(e) => {
                    content.push_str(&format!("Cannot read sheet {}\n", sheet_name));
                    eprintln!("Failed to read worksheet {}: {}", sheet_name, e);
                }
            }
        }

        Ok(content)
    }
```

**核心功能：**输入excel文件路径，使用 `open_workbook_auto` 函数打开 Excel 文件，通过 `workbook.sheet_names()` 获取所有工作表的名称，并遍历每个工作表，通过 `worksheet_range` 方法获取工作表的范围，并遍历每一行数据，根据不同类型的单元格数据（字符串、浮点数、整数、布尔值等），将其转换为字符串格式，将工作表名称及其内容逐行追加到字符串变量 `content` 中，在无法读取工作表时记录错误信息，并在最终结果中添加提示

**特性：**自动化处理，能够自动识别 Excel 文件的格式；覆盖所有的工作表，确保所有的工作表都能被处理；逐行读取数据，避免一次性加载整个工作表到内存中；支持多种数据类型，确保不同格式的数据都能被正确转换；健壮性，使某些工作表无法读取，也不会导致整个函数失败

### 2：按照Sheet读取Excel文件中的所有内容，并以字符串形式返回

```rust
    pub fn read_excel_as_string_by_sheet(file_path: &str) -> Result<Vec<String>> {
        // 打开Excel文件
        let mut workbook = open_workbook_auto(Path::new(file_path)).unwrap();
        let mut contents: Vec<String> = Vec::new();

        // 遍历所有工作表
        for sheet_name in workbook.sheet_names().to_owned() {
            let mut content = String::new();
            content.push_str(&format!("Sheet: {}\n", sheet_name));
            
            match workbook.worksheet_range(&sheet_name) {
                Ok(range) => {
                    for row in range.rows() {
                        let mut row_content = String::new();
                        for cell in row {
                            let cell_content = match cell {
                                Data::String(s) => s.clone(),
                                Data::Float(f) => f.to_string(),
                                Data::Int(i) => i.to_string(),
                                Data::Bool(b) => b.to_string(),
                                Data::Empty => "".to_string(),
                                _ => "?".to_string(), // 未知或复杂类型
                            };
                            row_content.push_str(&cell_content);
                            row_content.push('\t'); // 每个单元格之间用制表符分隔
                        }
                        content.push_str(&row_content);
                        content.push('\n'); // 每行结束后换行
                    }
                },
                Err(e) => {
                    content.push_str(&format!("Cannot read sheet {}\n", sheet_name));
                    eprint!("Failed to read worksheet {}: {}", sheet_name, e);
                }
            }
            contents.push(content);
        }
        Ok(contents)
    }
```

**核心功能：**传入文件路径，使用 `open_workbook_auto` 函数打开 Excel 文件，通过 `workbook.sheet_names()` 获取所有工作表的名称，并遍历每个工作表，通过 `worksheet_range` 方法获取工作表的范围，并遍历每一行数据，将每个工作表的内容逐行追加到字符串变量 `content` 中，并将每个工作表的 `content` 添加到向量 `contents` 中，通过在每行数据之间添加制表符 (`\t`) 和换行符 (`\n`)，使得输出内容格式清晰。将每个工作表的内容分别存储在一个向量中，方便后续处理

**特性：**能够自动识别 Excel 文件的格式；逐步构建每个工作表的最终字符串内容，避免一次性生成大量字符串的开销；逐行读取数据，避免一次性加载整个工作表到内存中；在结果字符串中包含错误信息，帮助用户了解哪些工作表存在问题；将每个工作表的内容分别存储在一个向量中，方便后续处理

### 3：按行读取excel文件内容，每一行一个向量，每个元素用制表符分隔

```rust
    pub fn read_excel_by_row(file_path: &str) -> Result<Vec<Vec<String>>> {
        // 打开Excel文件
        let mut workbook = open_workbook_auto(Path::new(file_path)).unwrap();
        let mut sheets = Vec::new();

        // 遍历所有工作表
        for sheet_name in workbook.sheet_names().to_owned() {
            // content.push_str(&format!("Sheet: {}\n", sheet_name));
            let mut sheet_content = Vec::new(); // 存储每个工作表的字符串
            match workbook.worksheet_range(&sheet_name) {
                Ok(range) => {
                    let rows = range.rows().collect::<Vec<_>>(); // 先收集所有行

                    // 如果没有行，则继续下一个工作表
                    if rows.is_empty() {
                        continue;
                    }
                    for row in rows {
                        let mut row_content = String::new();
                        for cell in row {
                            // let cell = row.get(col_index).unwrap_or(&Data::Empty); // 处理缺少的单元格
                            let cell_content = match cell {
                                Data::String(s) => s.clone(),
                                Data::Float(f) => f.to_string(),
                                Data::Int(i) => i.to_string(),
                                Data::Bool(b) => b.to_string(),
                                Data::Empty => "".to_string(),
                                _ => "?".to_string(), // 未知或复杂类型
                            };
                            row_content.push_str(&cell_content);
                            row_content.push('\t'); // 每个单元格之间用制表符分隔
                        }
                        sheet_content.push(row_content);
                    }
                },
                Err(e) => {
                    sheet_content.push(format!("Cannot read sheet {}\n", sheet_name));
                    eprintln!("Failed to read worksheet {}: {}", sheet_name, e);
                }
            }
            sheets.push(sheet_content);
        }

        Ok(sheets)
    }
```

**核心功能：**输入文件路径，使用 `open_workbook_auto` 函数打开 Excel 文件，通过 `workbook.sheet_names()` 获取所有工作表的名称，并遍历每个工作表，通过 `worksheet_range` 方法获取工作表的范围，并遍历每一行数据，根据不同类型的单元格数据（字符串、浮点数、整数、布尔值等），将其转换为字符串格式，将每个工作表的内容逐行追加到字符串变量 `row_content` 中，并将每个工作表的内容添加到向量 `sheets` 中，返回一个包含每个工作表内容的字符串向量的向量，每一行内容作为一个字符串

**特性：**通过使用 `&str` 作为文件路径，确保传递的是字符串类型；能够自动识别 Excel 文件的格式；逐行读取数据，避免一次性加载整个工作表到内存中；支持多种数据类型，确保不同格式的数据都能被正确转换；逐步构建每个工作表的最终字符串内容，避免一次性生成大量字符串的开销；即使某些工作表无法读取，也不会导致整个函数失败

### 4：按列读取excel文件内容，每一列一个向量，每个元素用制表符分隔

```rust
    pub fn read_excel_by_column(file_path: &str) -> Result<Vec<Vec<String>>> {
        // 打开Excel文件
        let mut workbook = open_workbook_auto(Path::new(file_path)).unwrap();
        let mut sheets = Vec::new();

        // 遍历所有工作表
        for sheet_name in workbook.sheet_names().to_owned() {
            // content.push_str(&format!("Sheet: {}\n", sheet_name));
            let mut sheet_content = Vec::new(); // 存储每个工作表的字符串
            match workbook.worksheet_range(&sheet_name) {
                Ok(range) => {
                    let rows = range.rows().collect::<Vec<_>>(); // 先收集所有行

                    // 如果没有行，则继续下一个工作表
                    if rows.is_empty() {
                        continue;
                    }

                    let column_count = rows[0].len(); // 假设每行的列数相同
    
                    // 遍历列
                    for col_index in 0..column_count {
                        let mut col_content = String::new();
                        for row in &rows {
                            let cell = row.get(col_index).unwrap_or(&Data::Empty); // 处理缺少的单元格
                            let cell_content = match cell {
                                Data::String(s) => s.clone(),
                                Data::Float(f) => f.to_string(),
                                Data::Int(i) => i.to_string(),
                                Data::Bool(b) => b.to_string(),
                                Data::Empty => "".to_string(),
                                _ => "?".to_string(), // 未知或复杂类型
                            };
                            col_content.push_str(&cell_content);
                            col_content.push('\t'); // 每个单元格之间用制表符分隔
                        }
                        sheet_content.push(col_content);
                    }
                },
                Err(e) => {
                    sheet_content.push(format!("Cannot read sheet {}\n", sheet_name));
                    eprintln!("Failed to read worksheet {}: {}", sheet_name, e);
                }
            }
            sheets.push(sheet_content);
        }

        Ok(sheets)
    }
```

**核心功能：**输入文件路径，使用 `open_workbook_auto` 函数打开 Excel 文件，通过 `workbook.sheet_names()` 获取所有工作表的名称，并遍历每个工作表，通过 `worksheet_range` 方法获取工作表的范围，并遍历每一行数据，然后按列重新组织数据。根据不同类型的单元格数据（字符串、浮点数、整数、布尔值等），将其转换为字符串格式，将每个工作表的内容按列逐行追加到字符串变量 `col_content` 中，并将每个工作表的内容添加到向量 `sheets` 中，在无法读取工作表时记录错误信息，并将错误信息添加到当前工作表的内容中，返回一个包含每个工作表内容的字符串向量的向量

**特性：**能够自动识别 Excel 文件的格式；确保所有的工作表都能被处理；提供了按列访问数据的能力，这对于某些数据分析任务非常有用；逐步构建每个工作表的最终字符串内容，避免一次性生成大量字符串的开销；支持多种数据类型，确保不同格式的数据都能被正确转换

### 5：按块读取excel文件，并按块格式化为字符串

```rust
        pub fn read_excel_by_block(file_path: &str, block_size: (usize, usize)) -> Result<Vec<String>> {
        // 打开Excel文件
        let mut workbook = open_workbook_auto(Path::new(file_path)).unwrap();
        let mut content =Vec::new();
        let (block_rows, block_cols) = block_size;

        // 遍历所有工作表
        for sheet_name in workbook.sheet_names().to_owned() {
            // content.push_str(&format!("Sheet: {}\n", sheet_name));

        match workbook.worksheet_range(&sheet_name) {
            Ok(range) => {
                let rows = range.rows().collect::<Vec<_>>(); // 先收集所有行
                let total_rows = rows.len();
                let total_cols = rows.get(0).map_or(0, |row| row.len()); // 使用get可能会返回none，map_or提供默认值0，和闭包，当get返回none值是，使用默认值，否则使用闭包计算

                // 按块遍历工作表内容
                for start_row in (0..total_rows).step_by(block_rows) { // 每次处理block_rows行数据
                    for start_col in (0..total_cols).step_by(block_cols) {
                        let mut block_content = String::new();

                        for r in start_row..(start_row + block_rows).min(total_rows) { //确保结束索引不会超过总行数 total_rows
                            for c in start_col..(start_col + block_cols).min(total_cols) {
                                let cell = rows[r].get(c).unwrap_or(&Data::Empty);
                                let cell_content = match cell {
                                    Data::String(s) => s.clone(),
                                    Data::Float(f) => f.to_string(),
                                    Data::Int(i) => i.to_string(),
                                    Data::Bool(b) => b.to_string(),
                                    Data::Empty => "".to_string(),
                                    _ => "?".to_string(),
                                };
                                block_content.push_str(&cell_content);
                                block_content.push('\t');
                            }
                            block_content.push('\n');
                        }
                        content.push(block_content);
                        // content.push('\n'); // 每块结束后添加换行符
                    }
                }
            },
            Err(e) => {
                content.push(format!("Cannot read sheet {}\n", sheet_name));
                eprintln!("Failed to read worksheet {}: {}", sheet_name, e);
            }
        }

    }
        Ok(content)
    }
```

**核心功能**：输入excel文件路径，使用 `open_workbook_auto` 函数打开 Excel 文件，通过 `workbook.sheet_names()` 获取所有工作表的名称，并遍历每个工作表，根据给定的行 (`block_rows`) 和列 (`block_cols`) 大小，按块读取数据，根据不同类型的单元格数据（字符串、浮点数、整数、布尔值等），将其转换为字符串格式，将每个工作表的内容按块逐行追加到字符串变量 `block_content` 中，并将每个块的内容添加到向量 `content` 中，在无法读取工作表时记录错误信息，并将错误信息添加到当前工作表的内容中，返回一个包含每个工作表内容的字符串向量

**特性：**能够自动识别 Excel 文件的格式；确保所有的工作表都能被处理；提供了按块读取数据的能力，对于处理大文件尤其有用；逐步构建每个工作表的最终字符串内容，避免一次性生成大量字符串的开销；支持多种数据类型，确保不同格式的数据都能被正确转换



## 八：读取ppt文件内容

- [x] PPTX文件中提取文本内容，文件内容以字符串形式返回
- [x] 按页读取pptx文件内容，每一页一个字符串
- [x] 读取PPT文件备注

### 1：PPTX文件中提取文本内容，文件内容以字符串形式返回

```rust
    pub fn read_pptx_text(file_path: &str) -> Result<String> {
        // 打开PPTX文件
        let file = File::open(Path::new(file_path))?;
        let mut archive = ZipArchive::new(file)?;
        let mut slide_texts = String::new();

        // 遍历PPTX文件中的所有文件
        for i in 0..archive.len() {
            let mut file = archive.by_index(i)?;
            let file_name = file.name().to_string();

            // 查找幻灯片文件（通常在ppt/slides/目录下，文件名以"slide"开头）
            if file_name.starts_with("ppt/slides/slide") && file_name.ends_with(".xml") {
                let mut xml_content = String::new();
                file.read_to_string(&mut xml_content)?;

                // 解析XML内容，提取文本
                let mut slide_text = String::new();
                let parser = EventReader::from_str(&xml_content);
                for event in parser {
                    match event {
                        Ok(XmlEvent::Characters(text)) => {
                            slide_text.push_str(&text);
                            slide_text.push('\n');
                        }
                        _ => {}
                    }
                }
                slide_texts.push_str(&slide_text.to_string());
            }
        }

        Ok(slide_texts)
    }
```

**核心功能**：输入PPT文件路径，使用 Rust 标准库中的 `std::fs::File` 和 `std::path::Path` 来打开文件，使用 `zip` 库来读取压缩包内的文件，通过迭代 ZIP 文件中的每一个条目来查找特定的幻灯片 XML 文件，读取每个幻灯片文件的内容，并使用事件驱动的 XML 解析器来提取文本，将提取的文本内容追加到字符串变量 `slide_text` 中，并最终追加到 `slide_texts` 中，在文件读取或 XML 解析过程中出现错误时，使用 `?` 运算符传播错误。最后返回一个包含所有幻灯片文本内容的字符串

**特性：**利用 Rust 标准库进行文件操作，确保类型安全和错误处理；使用 `zip` 库管理 ZIP 文件内部的资源，只读取需要的部分文件；使用事件驱动的 XML 解析器提取文本内容，提高灵活性；逐步构建每个幻灯片的文本内容，避免一次性生成大量字符串的开销

### 2：按页读取pptx文件内容，每一页一个字符串

```rust
    pub fn read_pptx_text_by_slide(file_path: &str) -> Result<Vec<String>> {
        // 打开PPTX文件
        let file = File::open(Path::new(file_path))?;
        let mut archive = ZipArchive::new(file)?;
        let mut slide_texts = Vec::new();

        // 遍历PPTX文件中的所有文件
        for i in 0..archive.len() {
            let mut file = archive.by_index(i)?;
            let file_name = file.name().to_string();

            // 查找幻灯片文件（通常在ppt/slides/目录下，文件名以"slide"开头）
            if file_name.starts_with("ppt/slides/slide") && file_name.ends_with(".xml") {
                let mut xml_content = String::new();
                file.read_to_string(&mut xml_content)?;

                // 解析XML内容，提取文本
                let mut slide_text = String::new();
                let parser = EventReader::from_str(&xml_content);
                for event in parser {
                    match event {
                        Ok(XmlEvent::Characters(text)) => {
                            slide_text.push_str(&text);
                            // slide_text.push('\n');
                        }
                        _ => {}
                    }
                }
                slide_texts.push(slide_text);
            }
        }

        Ok(slide_texts)
    }
```

**核心功能**：输入PPT文件路径，打开文件，由于PPTX 文件是一个 ZIP 压缩包，因此使用 `zip` 库来读取压缩包内的文件，通过迭代 ZIP 文件中的每一个条目来查找特定的幻灯片 XML 文件，读取每个幻灯片文件的内容，并使用事件驱动的 XML 解析器来提取文本，将提取的文本内容追加到字符串变量 `slide_text` 中，并最终追加到 `slide_texts` 向量中，在文件读取或 XML 解析过程中出现错误时，使用 `?` 运算符传播错误。返回值为字符串向量，每一个字符串都是一张幻灯片的文本内容

**特性：**每个幻灯片的文本作为一个单独的字符串存储在一个向量中，便于后续处理；使用事件驱动的 XML 解析器提取文本内容，提高灵活性；逐步构建每个幻灯片的文本内容，避免一次性生成大量字符串的开销；利用 Rust 标准库进行文件操作，确保类型安全和错误处理

### 3：读取PPT文件备注

```rust
    pub fn read_pptx_notes(file_path: &str) -> Result<Vec<String>> {
        let file = File::open(Path::new(file_path))?;
        let mut archive = ZipArchive::new(file)?;
    
        let mut notes = Vec::new();
    
        // 遍历PPTX文件中的所有文件
        for i in 0..archive.len() {
            let mut file = archive.by_index(i)?;
            if file.name().starts_with("ppt/notesSlides/notesSlide") && file.name().ends_with(".xml") {
                let mut xml_content = String::new();
                file.read_to_string(&mut xml_content)?;
            
                // Parse XML content
                let parser = EventReader::from_str(&xml_content);
                let mut note_content = String::new();
                let mut in_text_run = false;
                for event in parser {
                    match event {
                        Ok(XmlEvent::StartElement { name, .. }) => {
                            if name.local_name == "t" {
                                // Start text node
                                in_text_run = true;
                            }
                        },
                        Ok(XmlEvent::Characters(text)) if in_text_run => {
                            note_content.push_str(&text);
                            note_content.push_str("\n");
                        },
                        Ok(XmlEvent::EndElement { name }) => {
                            if name.local_name == "t" {
                                in_text_run = false;
                            }
                        },
                        Err(_) => {
                            // Handle error
                            break;
                        },
                        _ => {}
                    }
                }
                if !note_content.is_empty() {
                    // println!("note is {}", &note_content);
                    // 这里主要是去除每条备注之后的序号
                    let note_content = note_content.trim_end_matches(|c: char| c.is_digit(10) || c.is_whitespace()).to_string();
                    notes.push(note_content);
                }
            }
        }
    
        Ok(notes)
    }
```

**核心功能**：传入PPT文件路径，使用 Rust 标准库中的 `std::fs::File` 和 `std::path::Path` 来打开文件，通过 `ZipArchive` 管理 ZIP 文件内部的资源，通过迭代 ZIP 文件中的每一个条目来查找特定的备注 XML 文件，读取每个备注文件的内容，并使用事件驱动的 XML 解析器来提取文本，将提取的文本内容追加到字符串变量 `note_content` 中，并最终追加到 `notes` 向量中，在提取备注内容后，去除每条备注之后可能存在的数字序号和空白字符，在文件读取或 XML 解析过程中出现错误时，使用 `?` 运算符传播错误。返回结果为字符串向量，每个字符串为每张幻灯片备注的内容
**特性：**使用 `zip` 库管理 ZIP 文件内部的资源；只关注备注文件，提高性能；使用事件驱动的 XML 解析器提取文本内容，提高灵活性；逐步构建每个备注的文本内容，避免一次性生成大量字符串的开销；除每条备注之后可能存在的数字序号和空白字符，确保备注内容干净整洁

## 九：读取JSONL文件内容

- [x] 按行读取JSONL文件内容

### 1：按行读取JSONL文件内容

```rust
    pub fn read_jsonl_by_line(file_path: &str) -> Result<Vec<Value>> {  
        let file = File::open(file_path)?;
        let reader = BufReader::new(file);
        let mut vec_json = Vec::new();
        for line in reader.lines() {
            let line = line?;
            let json_value = from_str(&line)?; // from_str 是 serde_json 库中的一个函数，用于将字符串解析为 serde_json::Value 类型
            vec_json.push(json_value);
        }
        Ok(vec_json)
    }
```

**核心功能：**输入json文件路径，打开文件，创建缓冲区，遍历json文件每一行内容，使用`from_str`函数解析每一行字符串，返回`serde_json::Value`类型数据。每一行数据就是一个`Value`,最终返回类型为`Value`的向量

**特性：**通过使用 `&str` 作为文件路径，确保传递的是字符串类型；使用 `?` 操作符和 `Result` 类型，使得错误处理更加明确和一致；逐行读取文件，避免一次性加载整个文件到内存中；逐行解析数据，避免一次性处理大量数据导致的内存压力

## 十：读取ZIP文件内容

- [x] 列出ZIP文件中所有文件目录
- [x] 读取ZIP压缩包中TXT文件内容
- [x] 读取ZIP压缩包中CSV文件内容
- [x] 读取ZIP压缩包中中JSON文件内容
- [x] 读取ZIP压缩包中中JSONL文件内容
- [x] 读取ZIP压缩包中中XML文件内容
- [x] 读取ZIP压缩包中中Markdown文件内容
- [x] 读取ZIP压缩包中excel文件内容
- [x] 读取ZIP压缩包中PPT,PPTX文件内容
- [x] 读取ZIP压缩包中PDF文件内容

### 1：列出ZIP文件中所有文件目录

```rust
    pub fn list_zip_filenames(file_path: &str, mut exclude_directories: bool) -> Result<Vec<String>> {
        exclude_directories = !exclude_directories;
        let file = File::open(file_path)?;
        let mut archive = ZipArchive::new(file)?;
    
        let file_list = (0..archive.len())
            .filter_map(|i| {
                archive.by_index(i).ok()
                    .filter(|entry| !exclude_directories || !entry.is_dir())
                    .map(|entry| entry.name().to_string())
            })
            .collect::<Vec<_>>();
    
        Ok(file_list)
    }
```

**核心功能：**传入压缩包文件路径，是否包含压缩包目录参数，使用 Rust 标准库来打开文件，通过 `zip` 库来读取压缩包内的文件，通过迭代 ZIP 文件中的每一个条目来获取文件名，使用 `filter_map` 来过滤掉不需要的条目，并将有效的条目转换为字符串，返回一个包含所有文件名的向量

**特性：**允许用户选择是否要包含目录在列表中，增加了灵活性；利用 Rust 标准库进行文件操作，确保类型安全和错误处理；使用 `zip` 库管理 ZIP 文件内部的资源；使用 `filter_map` 来过滤掉不需要的条目，并将有效的条目转换为字符串

### 2：读取ZIP压缩包中TXT文件内容

```rust
    // 拼接路径函数
    fn join_path(path1: &str, path2: &str) -> String {
        let mut full_path = PathBuf::from(path1);
        full_path.push(path2);
        full_path.to_string_lossy().into_owned().replace("\\", "/")
    }

    // 读取zip内文本文件内容
    pub fn read_zip_txt(zip_path: &str, file_name: &str) -> Result<String> {
        let zip_file = File::open(zip_path)?;
        let mut archive = ZipArchive::new(zip_file)?;
        // 打开指定文件
        let mut file = archive.by_name(file_name)?;
        let mut reader = BufReader::new(file);
        let mut contents = String::new();
        reader.read_to_string(&mut contents)?;
    
        Ok(contents)
    }
```

**核心功能：**第一个函数，接受两个字符串参数，将它们拼接成一个完整的路径，使用 `to_string_lossy()` 将 `PathBuf` 转换为字符串，并替换掉反斜杠 (`\`) 为正斜杠 (`/`)，以确保在不同操作系统上的一致性。第二个函数，接受压缩包文件路径和压缩包中相应文件的路径，通过 `by_name` 方法打开 ZIP 文件中的指定文件，并使用缓冲读取器读取文件内容，返回一个包含指定文件内容的字符串

**特性：**通过替换路径分隔符确保路径在不同操作系统上的一致性；使用缓冲读取器提高读取文件的效率，并确保在文件读取过程中任何错误都能被正确处理；使用 `zip` 库管理 ZIP 文件内部的资源，只读取需要的部分文件

### 3：读取ZIP压缩包中CSV文件内容

```rust
    pub fn read_zip_csv(zip_path: &str, file_name: &str) -> Result<Vec<Vec<String>>> {
        let zip_file = File::open(zip_path)?;
        let mut archive = ZipArchive::new(zip_file)?;
        // 打开指定文件
        let mut file = archive.by_name(file_name)?;
        //ReaderBuilder 是一个用于构建 Reader 实例的构造器，允许用户配置 Reader 的行为，创建一个 CSV 读取器
        let mut rdr = ReaderBuilder::new().from_reader(file);
        let mut records = Vec::new();
        // 每一行是一条记录，vec<String>
        for result in rdr.records() {
            let record = result?;
            let record_vec: Vec<String> = record.iter().map(|s| s.to_string()).collect();
            records.push(record_vec);
        }
    
        Ok(records)
    }
```

**核心功能：**接受压缩包文件路径和压缩包中相应CSV文件的路径，使用 Rust 标准库中的 `std::fs::File` 和 `std::path::Path` 来打开文件，ZIP 文件通过 `zip` 库来读取压缩包内的文件，通过 `by_name` 方法打开 ZIP 文件中的指定文件，并使用 CSV 读取器读取文件内容，使用 CSV 读取器的 `records` 方法来读取每一行记录，并将每一行转换为字符串向量，每一行 CSV 记录被转换为一个字符串向量，使得数据更容易处理。最后返回一个包含所有 CSV 记录的二维字符串向量

**特性：**每一行 CSV 记录被转换为一个字符串向量，使得数据更容易处理；使用 `csv` 库的 `ReaderBuilder` 创建 CSV 读取器，并确保在文件读取过程中任何错误都能被正确处理；使用 `zip` 库管理 ZIP 文件内部的资源，只读取需要的部分文件

### 4： 读取ZIP压缩包中中JSON文件内容

```rust
    pub fn read_zip_json(zip_path: &str, file_name: &str) -> serde_json::Result<Value> {
        let zip_file = File::open(zip_path).unwrap();
        let mut archive = ZipArchive::new(zip_file).unwrap();
        // 打开指定文件
        let mut file = archive.by_name(file_name).unwrap();
        let reader = BufReader::new(file);

        // 直接解析为serde_json::Value
        let json_data: Value = serde_json::from_reader(reader)?; // 尝试从 reader 中解析 JSON 数据

        Ok(json_data)
    }
```

**核心功能：**接受压缩包文件路径和压缩包中相应文件的路径，使用 Rust 标准库中的 `std::fs::File` 和 `std::path::Path` 来打开文件，使用 `BufReader` 包装 `File`，提高大文件的读取效率，使用 `serde_json` 库的 `from_reader` 方法直接从 `BufReader` 中解析 JSON 数据，使用 `serde_json::Result<Value>` 返回类型，确保函数返回一个结果，其中包含了可能发生的错误。返回通用的 JSON 数据结构`serde_json::Value`，存储JSON文件内容

**特性：**通过使用 `BufReader` 提高大文件的读取效率；使用 `serde_json` 库的 `from_reader` 方法直接从 `BufReader` 中解析 JSON 数据，确保类型安全和数据的灵活性；通过 `serde_json::Result<Value>` 返回类型，确保函数的健壮性，并帮助用户了解哪些部分可能出现问题

### 5：读取ZIP压缩包中中JSONL文件内容

```rust
    pub fn read_zip_jsonl(zip_path: &str, file_name: &str) -> Result<Vec<Value>> {  
        let zip_file = File::open(zip_path)?;
        let mut archive = ZipArchive::new(zip_file)?;
        // 打开指定文件
        let mut file = archive.by_name(file_name)?;
        let reader = BufReader::new(file);

        let mut vec_json = Vec::new();

        for line in reader.lines() {
            let line = line?;
            let json_value = from_str(&line)?; // from_str 是 serde_json 库中的一个函数，用于将字符串解析为 serde_json::Value 类型
            vec_json.push(json_value);
        }
        Ok(vec_json)
    }
```

**核心功能：**接受压缩包文件路径和压缩包中相应文件的路径，打开文件，通过 `ZipArchive` 管理 ZIP 文件内部的资源，使用 `BufReader` 包装 `File`，提高大文件的读取效率，逐行读取JSONL文件，使用 `lines` 方法逐行读取文件内容，并对每一行进行解析，使用 `serde_json` 库的 `from_str` 方法逐行解析 JSON数据，使用 `Result` 类型返回结果，确保函数可以正确处理文件打开、解压和 JSON 解析过程中的任何错误

**特性：**逐行读取文件内容，并对每一行进行解析，提高内存效率；使用 `serde_json` 库的 `from_str` 方法逐行解析 JSON 数据，确保类型安全和数据的灵活性；通过使用 `BufReader` 提高大文件的读取效率；使用 `zip` 库管理 ZIP 文件内部的资源，只读取需要的部分文件

### 6：读取ZIP压缩包中中XML文件内容

```rust
    pub fn read_zip_xml<S, T, E>(
        zip_path: &str, 
        file_name: &str,
        mut on_start: S,
        mut on_text: T,
        mut on_end: E,
    ) -> Result<()> // 表示可能成功或失败
    where
        S: FnMut(&str), // 可以多次可变调用的闭包
        T: FnMut(&str),
        E: FnMut(&str),
    {
        let zip_file = File::open(zip_path)?;
        let mut archive = ZipArchive::new(zip_file)?;
        // 打开指定文件
        let mut file = archive.by_name(file_name)?;
        let reader = BufReader::new(file);
        let mut xml_reader = quick_xml::Reader::from_reader(reader); // 创建一个 XML 读取器，用于从缓冲读取器中读取 XML 数据
        xml_reader.trim_text(true); // 去除文本节点中的空白字符
        let mut buf = Vec::new();
        loop { // 无限循环，直至有break退出
            match xml_reader.read_event_into(&mut buf) { // 读取下一个 XML 事件，并将其存储到 buf 中
                Ok(Event::Start(ref e)) => { // 如果事件是一个开始标签，提取标签名称并调用 on_start 闭包
                    let element_name = String::from_utf8_lossy(e.name().as_ref()).to_string();
                    on_start(&element_name);
                }
                Ok(Event::Text(e)) => { // 如果事件是一个文本节点，解码文本并调用 on_text 闭包
                    let text = e.unescape().unwrap().to_string();
                    on_text(&text); // 可根据需要获取文本节点内容
                }
                Ok(Event::End(ref e)) => { // 如果事件是一个结束标签，提取标签名称并调用 on_end 闭包。
                    let element_name = String::from_utf8_lossy(e.name().as_ref()).to_string();
                    on_end(&element_name);
                }
                Ok(Event::Eof) => break, // 文件结束
                Err(e) => {
                    eprintln!("Error at position {}: {:?}", xml_reader.buffer_position(), e);
                    break;
                }
                _ => {}
            }

            buf.clear(); // 清除缓冲区
        }
        Ok(()) // 如果一切正常，返回一个成功结果。
    }
```

**核心功能：**传入压缩包文件路径和压缩包中相应文件的路径，同时传入三个泛型参数 `S`, `T`, `E` 分别对应于 XML 的开始标签、文本节点和结束标签的回调函数，通过 `zip` 库来读取压缩包内的文件，通过使用缓冲读取器 `BufReader`，使用 `quick_xml` 库的 `Reader` 结构体来解析 XML 数据，使用 `Result` 类型返回结果，确保函数可以正确处理文件打开、解压和 XML 解析过程中的任何错误。回调机制，当遇到开始标签、文本节点和结束标签时，分别调用用户提供的回调函数
**特性：**许用户定义自己的回调函数来处理 XML 事件，增加了灵活性；通过使用 `BufReader` 提高大文件的读取效率；使用 `quick_xml` 库的事件驱动方式解析 XML 数据，确保类型安全和数据的灵活性；用户可以根据需要处理 XML 事件，增加了代码的可维护性和灵活性

### 7：读取ZIP压缩包中Markdown文件内容

```rust
    pub fn read_zip_md(zip_path: &str, file_name: &str) -> Result<Vec<String>> {
        let zip_file = File::open(zip_path)?;
        let mut archive = ZipArchive::new(zip_file)?;
        // 打开指定文件
        let mut file = archive.by_name(file_name)?;
        let mut reader = BufReader::new(file);
        let mut lines = Vec::new();

        loop {
            let mut line = String::new();
            match reader.read_line(&mut line) {
                Ok(0) => break, // 0 表示读到的字节数，0，表示读到文件末尾
                Ok(_) => lines.push(line.trim_end_matches('\n').to_string()), // 正常读取
                Err(e) => return Err(e), // 读取错误
    
            }
        }

        Ok(lines)
    }
```

**核心功能：**传入压缩包文件路径和压缩包中相应文件的路径，使用 Rust 标准库中的 `std::fs::File` 和 `std::path::Path` 来打开文件，通过 `zip` 库来读取压缩包内的文件，使用 `BufReader` 包装 `File`，使用 `read_line` 方法逐行读取文件内容，并去除每行结尾的换行符。最后返回字符串向量，每一个字符串表示文件一行内容

**特性：**通过使用 `BufReader` 提高大文件的读取效率；使用 `zip` 库管理 ZIP 文件内部的资源，只读取需要的部分文件

### 8：读取ZIP压缩包中excel文件内容

```rust
    pub fn read_zip_excel(zip_path: &str, file_name: &str) -> Result<Vec<String>> {
        let zip_file = File::open(zip_path)?;
        let mut archive = ZipArchive::new(zip_file)?;

        // 打开指定文件
        let mut file = archive.by_name(file_name)?;

        // 创建一个临时缓冲区来存储Excel文件内容
        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer)?;

        // 使用calamine读取Excel文件
        let mut workbook = Xlsx::new(std::io::Cursor::new(buffer)).unwrap();

        let mut lines = Vec::new();

        // 遍历每一个工作表
        for (sheet_number, (sheet_name, sheet)) in workbook.worksheets().into_iter().enumerate() {
            for (row_number, row) in sheet.rows().enumerate() {
                let mut line = String::new();
                // Process each row as needed
                // For example, you can iterate over the cells in the row
                for cell in row {
                    line.push_str(&cell.to_string());
                    line.push(' '); // Add a space between cells for readability
                }
                lines.push(line);
            }
        }

        Ok(lines)
    }
```

**核心功能：**输入压缩包文件路径`zip_path`即和压缩包中相应文件的路径`file_name`，使用 Rust 标准库来打开文件，通过 `zip` 库来读取压缩包内的文件，使用 `BufReader` 包装 `File`，提高大文件的读取效率，使用 `calamine` 库来读取 Excel 文件的内容，使用 `calamine` 库遍历每一个工作表，并将每一行内容作为一个字符串存储到向量中。最后返回字符串向量，其中每一个字符串为excel表中一行内容

**特性：**使用 `calamine` 库来读取 Excel 文件的内容，提供强大的功能和类型安全；将每一行数据按照单元格的形式存储到字符串中，方便进一步处理；使用 `BufReader` 提高大文件的读取效率；使用 `zip` 库管理 ZIP 文件内部的资源，只读取需要的部分文件；利用 Rust 标准库进行文件操作，确保类型安全和错误处理

### 9：读取ZIP压缩包中PPT,PPTX文件内容

```rust
    pub fn read_zip_pptx(zip_path: &str, file_name: &str) -> Result<Vec<String>> {
        let zip_file = File::open(zip_path)?;
        let mut archive = ZipArchive::new(zip_file)?;

        // 找到指定的PPTX文件
        let mut file = archive.by_name(file_name)?;

        // 将PPTX文件内容读取到内存中
        let mut pptx_buffer = Vec::new();
        file.read_to_end(&mut pptx_buffer)?;

        // 使用Cursor包装字节数组，以便支持Seek操作
        let mut cursor = Cursor::new(pptx_buffer);

        // 从Cursor创建一个新的ZipArchive
        let mut pptx_archive = ZipArchive::new(&mut cursor)?;

        let mut slide_texts = Vec::new();

        // 遍历PPTX文件中的所有文件
        for i in 0..pptx_archive.len() {
            let mut file = pptx_archive.by_index(i)?;
            let file_name = file.name().to_string();

            // 查找幻灯片文件（通常在ppt/slides/目录下，文件名以"slide"开头）
            if file_name.starts_with("ppt/slides/slide") && file_name.ends_with(".xml") {
                let mut xml_content = String::new();
                file.read_to_string(&mut xml_content)?;

                // 解析XML内容，提取文本
                let mut slide_text = String::new();
                let parser = EventReader::from_str(&xml_content);
                for event in parser {
                    match event {
                        Ok(XmlEvent::Characters(text)) => {
                            slide_text.push_str(&text);
                            // slide_text.push('\n');
                        }
                        _ => {}
                    }
                }
                slide_texts.push(slide_text);
            }
        }

        Ok(slide_texts)
    }
```

**核心功能：**传入ZIP压缩包文件路径、压缩包内PPT文件路径，使用Rust标准库打开文件，并使用 `ZipArchive` 管理 ZIP 文件内部的资源，先将文件内容读取到内存中，方便后续处理。使用 `Cursor` 包装字节数组，以便支持 `Seek` 操作，并从 `Cursor` 创建一个新的 `ZipArchive`，接着遍历 PPTX 文件中的所有文件，查找幻灯片文件（通常在 `ppt/slides/` 目录下，文件名以 "slide" 开头），然后读取幻灯片文件内容，解析 XML 内容，并提取文本。最后返回结果，包含每张PPT幻灯片内容的字符串向量

**特性：**使用断言 (`assert!`) 来保证文件路径正确性和文件类型正确性，提高了程序的健壮性；使用 `Vec` 和 `Cursor` 来将ZIP文件内容读取到内存中，并支持随机访问；从ZIP归档中提取出XML文件，并使用 `EventReader` 来解析XML内容；将每个幻灯片的文本内容合并到一个字符串中，并在每个幻灯片之间插入换行符，方便阅读

### 10：读取ZIP压缩包中PDF文件内容

```rust
    pub fn read_zip_pdf_text(zip_path: &str, file_name: &str) -> Result<String> {
        // 检查ZIP文件是否存在
        assert!(fs::metadata(zip_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(zip_path.ends_with(".zip"), "文件类型错误,请检查文件类型是否为zip文件");
    
        // 打开ZIP文件
        let zip_file = File::open(zip_path)?;
    
        // 创建 ZIP 归档实例
        let mut archive = ZipArchive::new(zip_file)?;
    
        // 查找并读取指定的PDF文件
        for i in 0..archive.len() {
            let mut file = archive.by_index(i)?;
            if file.name() == file_name {
                assert!(file_name.ends_with(".pdf"), "文件类型错误,请检查文件类型是否为pdf文件");
                // 创建临时文件
                let temp_dir = tempfile::tempdir()?;
                let temp_file_path = temp_dir.path().join("temp.pdf");
    
                // 将PDF文件内容写入临时文件
                let mut temp_file = File::create(&temp_file_path)?;
                let mut buf = Vec::new();
                file.read_to_end(&mut buf)?;
                temp_file.write_all(&buf)?;
    
                // 从临时文件中读取PDF内容
                let pdf_text = extract_text(temp_file_path.to_str().unwrap());
                match pdf_text {
                    Ok(text) => return Ok(text.trim_start_matches('\n').trim_end_matches('\n').to_string()),
                    Err(err) => return Err(Error::new(ErrorKind::Other, format!("Failed to extract PDF text: {}", err))),
                }
            }
        }
    
        Err(Error::new(ErrorKind::NotFound, "PDF文件不存在"))
    }
```

**核心功能：**输入压缩包路径，读取的文件相对于压缩包的相对路径，使用 `File::open` 和 `ZipArchive::new` 来打开ZIP文件并创建ZIP归档对象，通过 `by_index` 方法遍历ZIP归档中的所有文件，查找指定的PDF文件，使用 `tempfile::tempdir` 创建一个临时目录，并在其中创建一个临时文件存储PDF内容，使用Rust库` extract_text` 函数来从PDF文件中提取文本内容，在提取文本后，对结果进行修剪，去除多余的空白行

**特性：**通过分离不同的任务（例如文件读取、临时文件创建、PDF内容提取），使得代码更具可读性和可维护性；使用 `tempfile::tempdir` 创建临时目录，并在其中创建临时文件来存储PDF内容，确保不会污染用户的文件系统；代码可以很容易地适应不同的PDF文本提取库，只要替换 `extract_text` 函数即可

## 十一：读取RAR文件内容

- [x] 列出 RAR 压缩包中的所有文件和目录
- [x] 读取 RAR 压缩包内的txt文件内容
- [x] 读取 RAR 压缩包中csv文件内容
- [x] 读取 RAR 中json文件内容
- [x] 读取 RAR 中jsonl文件内容
- [x] 读取 RAR 中xml文件内容
- [x] 读取 RAR 中Markdown文件内容
- [x] 读取 RAR 中excel文件内容
- [x] 读取 RAR 中pdf文件内容
- [x] 读取 RAR 中ppt文件内容

### 1：列出 RAR 中的所有文件和目录

```rust
	pub fn list_rar_filenames(rar_path: &str, exclude_directories: bool) -> Result<Vec<String>> {
        assert!(fs::metadata(rar_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(rar_path.ends_with(".rar"), "文件类型错误,请检查文件类型是否为rar文件");

        let archive = Archive::new(rar_path);
        let entries = archive.open_for_listing().unwrap();
    
        let file_list = entries
            .filter_map(|entry| {
                entry.ok()
                    .and_then(|e| {
                        if !exclude_directories && e.is_directory() {
                            None
                        } else {
                            e.filename.to_str().map(|s| s.to_string())
                        }
                    })
            })
            .collect::<Vec<_>>();
    
        Ok(file_list)
    }
```

**核心功能：**传入RAR压缩包文件路径，是否包含目录参数，使用 `unrar` 库来处理 RAR 文件，通过 `Archive::new` 创建一个 RAR 归档对象，管理 RAR 文件内部的资源。然后使用 `open_for_listing` 方法打开归档文件进行列表展示，使用 `filter_map` 方法过滤出需要的文件名，并转换为字符串。最后返回结果，列出RAR压缩包下所有文件目录结构和文件

**特性：**利用 `unrar` 库进行文件操作，确保类型安全和错误处理；只读取需要的部分文件，而不是一次性解压整个文件；使用迭代器链式调用来简化代码逻辑，同时确保转换后的结果是有效的字符串；通过特定的方法读取归档文件的元数据，不需要解压整个文件；代码代码简洁，易于理解和维护

### 2：读取 RAR 内的txt文件内容

```rust
    pub fn read_rar_txt(rar_path: &str, file_name: &str) -> UnrarResult<String> {
        assert!(std::fs::metadata(rar_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(rar_path.ends_with(".rar"), "文件类型错误,请检查文件类型是否为rar文件");
    
        let mut archive = Archive::new(rar_path).open_for_processing()?;
    
        loop {
            let header = archive.read_header()?;
            if header.is_none() {
                return Err(UnrarError::from(unrar::error::Code::EndArchive, unrar::error::When::Read));
            }
    
            let header = header.unwrap();
            if header.entry().filename.to_str().unwrap() == file_name {
                let (file_data, _) = header.read()?;
                return Ok(String::from_utf8_lossy(&file_data).to_string());
            }
            
            archive = header.skip()?;
        }
    }
```

**核心功能：**输入RAR路径与文本文件名，验证文件存在性及RAR格式，利用`unrar`库创建并打开RAR存档，循环读取直至匹配目标文件名，读取文件数据并转换为UTF-8字符串返回。

**特性：**确保路径与格式正确避免无效操作；逐文件处理而非整体解压，提升效率与安全性；直接读取并转换匹配文件数据，减少资源消耗；异常处理保障流程健壮性；代码结构清晰，易于调试与维护。

### 3：读取 RAR 中csv文件内容

```rust
   pub fn read_rar_csv(rar_path: &str, file_name: &str) -> UnrarResult<Vec<Vec<String>>> {
        assert!(std::fs::metadata(rar_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(rar_path.ends_with(".rar"), "文件类型错误,请检查文件类型是否为rar文件");

        let mut archive = Archive::new(rar_path).open_for_processing()?;

        loop {
            let header = archive.read_header()?;
            if header.is_none() {
                return Err(UnrarError::from(unrar::error::Code::EndArchive, unrar::error::When::Read));
            }

            let header = header.unwrap();
            if header.entry().filename.to_str().unwrap() == file_name {
                let (file_data, _) = header.read()?;
                
                let reader = BufReader::new(&file_data[..]);
                let mut rdr = ReaderBuilder::new().from_reader(reader);
                let mut records = Vec::new();
                
                for result in rdr.records() {
                    let record = result.map_err(|_| UnrarError::from(unrar::error::Code::Unknown, unrar::error::When::Read))?;
                    let record_vec: Vec<String> = record.iter().map(|s| s.to_string()).collect();
                    records.push(record_vec);
                }
                return Ok(records);
            }

            archive = header.skip()?;
        }
    }
```

**核心功能：**接收RAR文件路径与CSV文件名作为参数，确认RAR文件可访问且格式正确，利用`unrar`库构建归档对象，遍历查找指定CSV文件，一旦发现则读取内容并转译为字符串向量集合返回。

**特性：**先验检查确保操作合法性，提高运行稳定性；对RAR文件非侵入式检索，提升性能且降低风险；针对CSV文件特性的读取与转换策略，增强数据处理准确性；灵活应对读取过程中的潜在错误，保证流程完整性；结果组织为二维向量，适应后续数据处理需求。

### 4：读取 RAR 中json文件内容

```rust
    pub fn read_rar_json(rar_path: &str, file_name: &str) -> UnrarResult<Value> {
        assert!(fs::metadata(rar_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(rar_path.ends_with(".rar"), "文件类型错误,请检查文件类型是否为rar文件");
    
        let mut archive = Archive::new(rar_path).open_for_processing()?;
    
        loop {
            let header = archive.read_header()?;
            if header.is_none() {
                return Err(UnrarError::from(unrar::error::Code::EndArchive, unrar::error::When::Read));
            }
    
            let header = header.unwrap();
            if header.entry().filename.to_str().unwrap() == file_name {
                let (file_data, _) = header.read()?;
    
                let reader = BufReader::new(&file_data[..]);
                let json_data: Value = from_reader(reader)
                    .map_err(|_| UnrarError::from(unrar::error::Code::Unknown, unrar::error::When::Read))?;
                
                return Ok(json_data);
            }
    
            archive = header.skip()?;
        }
    }
```

**核心功能：**此函数旨在定位并解析RAR压缩包内的JSON文件，首先校验文件路径和格式，接着通过`unrar`库读取归档中的指定文件，将其内容解析为JSON数据结构后返回。

**特性：**内置预检机制防止无效路径与格式错误导致的程序崩溃；精准读取所需JSON文件而不完全解压RAR档案，优化加载速度；直接转换二进制流至JSON值，适用于快速数据提取与处理；异常捕获确保流程鲁棒性，避免因单一环节失败影响整体执行。

### 5：读取 RAR 中jsonl文件内容

```rust
     pub fn read_rar_jsonl(rar_path: &str, file_name: &str) -> UnrarResult<Vec<Value>> {
        assert!(fs::metadata(rar_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(rar_path.ends_with(".rar"), "文件类型错误,请检查文件类型是否为rar文件");
    
        let mut archive = Archive::new(rar_path).open_for_processing()?;
    
        loop {
            let header = archive.read_header()?;
            if header.is_none() {
                return Err(UnrarError::from(unrar::error::Code::EndArchive, unrar::error::When::Read));
            }
    
            let header = header.unwrap();
            if header.entry().filename.to_str().unwrap() == file_name {
                let (file_data, _) = header.read()?;
    
                let reader = BufReader::new(&file_data[..]);
                let mut vec_json = Vec::new();
    
                for line in reader.lines() {
                    let line = line.map_err(|_| 
                        UnrarError::from(unrar::error::Code::Unknown, unrar::error::When::Read))?;
                    let json_value = from_str(&line)
                        .map_err(|_| UnrarError::from(unrar::error::Code::Unknown, unrar::error::When::Read))?;
                    vec_json.push(json_value);
                }
    
                return Ok(vec_json);
            }
    
            archive = header.skip()?;
        }
    }
```

**核心功能：**本函数专注于读取RAR压缩包中指定的JSON Lines文件，逐一解析每一行JSON数据到内存数组，支持批量数据提取。

**特性：**具备前置检查能力，确保目标RAR文件存在并符合预期；针对性地读取单个JSONL文件而无需解压全部内容，显著节省资源；逐行解析JSONL文件，适配大数据集高效处理；内置错误处理逻辑，确保数据读取过程中任何异常均能得到妥善反馈；最终返回完整的JSON值向量，便于进一步的数据分析与应用

### 6：读取 RAR 中xml文件内容

```rust
    pub fn read_rar_xml<S, T, E>(
        rar_path: &str, 
        file_name: &str,
        mut on_start: S,
        mut on_text: T,
        mut on_end: E,
    ) -> UnrarResult<()>
    where
        S: FnMut(&str), 
        T: FnMut(&str),
        E: FnMut(&str),
    {
        assert!(fs::metadata(rar_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(rar_path.ends_with(".rar"), "文件类型错误,请检查文件类型是否为rar文件");
    
        let mut archive = unrar::Archive::new(rar_path).open_for_processing()?;
    
        loop {
            let header = archive.read_header()?;
            if header.is_none() {
                return Err(UnrarError::from(unrar::error::Code::EndArchive, unrar::error::When::Read));
            }
    
            let header = header.unwrap();
            if header.entry().filename.to_str().unwrap() == file_name {
                let (file_data, _) = header.read()?;
                let reader = BufReader::new(&file_data[..]);
                let mut xml_reader = quick_xml::Reader::from_reader(reader);
                xml_reader.trim_text(true);
                let mut buf = Vec::new();
    
                loop {
                    match xml_reader.read_event_into(&mut buf).unwrap() {
                        Event::Start(ref e) => {
                            let element_name = String::from_utf8_lossy(e.name().as_ref()).to_string();
                            on_start(&element_name);
                        }
                        Event::Text(e) => {
                            let text = e.unescape().unwrap().to_string();
                            on_text(&text);
                        }
                        Event::End(ref e) => {
                            let element_name = String::from_utf8_lossy(e.name().as_ref()).to_string();
                            on_end(&element_name);
                        }
                        Event::Eof => break,
                        _ => {}
                    }
                    buf.clear();
                }
    
                return Ok(());
            }
    
            archive = header.skip()?;
        }
    }
```

**核心功能：**此函数从RAR压缩包中读取指定XML文件，逐元素解析XML内容，通过回调函数实时反馈XML结构信息

**特性：**具备前期文件校验，确认RAR文件存在性与格式正确性，增强操作可靠性；精准定位并读取指定XML文件，避免不必要的资源消耗；采用流式解析策略，边读边处理，适合大规模XML数据的高效解析；通过回调机制，允许外部代码自定义处理XML的开始标签、文本和结束标签，提供高度灵活的数据处理方案；内置错误处理，确保解析流程的健壮性，同时减少内存占用，提高解析速度。

### 7：读取 RAR 中Markdown文件内容

```rust
   pub fn read_rar_markdown(rar_path: &str, file_name: &str) -> UnrarResult<String> {
        assert!(fs::metadata(rar_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(rar_path.ends_with(".rar"), "文件类型错误,请检查文件类型是否为rar文件");
    
        let mut archive = Archive::new(rar_path).open_for_processing()?;
    
        loop {
            let header = archive.read_header()?;
            if header.is_none() {
                return Err(UnrarError::from(unrar::error::Code::EndArchive, unrar::error::When::Read));
            }
    
            let header = header.unwrap();
            if header.entry().filename.to_str().unwrap() == file_name {
                let (file_data, _) = header.read()?;
                let mut reader = BufReader::new(&file_data[..]);
                let mut content = String::new();
                reader.read_to_string(&mut content).unwrap();
                return Ok(content);
            }
    
            archive = header.skip()?;
        }
    }
```

**核心功能：**这段代码旨在从RAR压缩包中读取特定的Markdown文件内容。它先验证文件路径和类型，接着定位并读取指定文件，然后将文件内容完整读入字符串中返回。

**特性：**文件预检查，确保目标RAR文件有效存在并为正确格式；精准读取，直接定位并读取指定Markdown文件，无需完全解压RAR文件；高效读取，通过缓冲读取器一次性读取文件全部内容至字符串，简化数据处理；直接返回文件内容，便于后续Markdown解析或展示使用。

### 8：读取 RAR 中excel文件内容

```rust
   pub fn read_rar_excel(rar_path: &str, file_name: &str) -> UnrarResult<Vec<String>> {
        assert!(fs::metadata(rar_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(rar_path.ends_with(".rar"), "文件类型错误,请检查文件类型是否为rar文件");
    
        let mut archive = Archive::new(rar_path).open_for_processing()?;
        let mut buffer = Vec::new();
    
        loop {
            let header = archive.read_header()?;
            if header.is_none() {
                return Err(UnrarError::from(unrar::error::Code::EndArchive, unrar::error::When::Read));
            }
    
            let header = header.unwrap();
            if header.entry().filename.to_str().unwrap() == file_name {
                let (file_data, _) = header.read()?;
                buffer.extend_from_slice(&file_data[..]);
                break;
            }
    
            archive = header.skip()?;
        }
    
        let mut workbook = Xlsx::new(std::io::Cursor::new(buffer)).unwrap();
        let mut lines = Vec::new();
    
        for (_, sheet) in workbook.worksheets().into_iter() {
            for row in sheet.rows() {
                let line = row.iter()
                    .map(|cell| cell.to_string())
                    .collect::<Vec<String>>()
                    .join(" ");
                lines.push(line);
            }
        }
    
        Ok(lines)
    }

```

**核心功能：**该段代码用于从RAR存档中读取Excel文件，并将其内容转化为字符串列表形式。

**特性：**初始的文件验证步骤，保证了RAR文件的存在性和正确格式，增强了程序的稳健性；精确定位与读取，能够直接获取存档内特定的Excel文件，无需全面解压整个RAR文件；借助Xlsx-rs库，能有效地解析Excel数据，即使文件包含多个工作表也能够一一读取所有单元格信息；将各单元格数据串联成行的形式存储入向量，方便后期进行数据分析或信息检索；统一的数据处理流程，无论是纯数值还是复杂的文本内容，都能得到正确的字符串表示；自动适应多工作表场景，确保每个表格数据都被充分读取，无遗漏。

### 9：读取 RAR 中pdf文件内容

```rust
   pub fn read_rar_pdf_as_string(rar_path: &str, file_name: &str) -> UnrarResult<String> {
        assert!(fs::metadata(rar_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(rar_path.ends_with(".rar"), "文件类型错误,请检查文件类型是否为rar文件");
    
        let mut archive = Archive::new(rar_path).open_for_processing()?;
    
        loop {
            let header = archive.read_header()?;
            if header.is_none() {
                return Err(UnrarError::from(unrar::error::Code::EndArchive, unrar::error::When::Read));
            }
    
            let header = header.unwrap();
            if header.entry().filename.to_str().unwrap() == file_name {
                assert!(file_name.ends_with(".pdf"), "文件类型错误,请检查文件类型是否为pdf文件");
                let temp_dir = tempdir().unwrap();
                let temp_file_path = temp_dir.path().join("temp.pdf");
    
                let (file_data, _) = header.read()?;
                let mut temp_file = File::create(&temp_file_path).unwrap();
                temp_file.write_all(&file_data).unwrap();
    
                let pdf_text = extract_text(temp_file_path.to_str().unwrap()).unwrap();
                return Ok(pdf_text.trim().to_string());
            }
    
            archive = header.skip()?;
        }
    
        Err(UnrarError::from(unrar::error::Code::EndArchive, unrar::error::When::Read))
    }
```

**核心功能：**从RAR压缩包中提取指定PDF文件的文字内容，转换为字符串

**特性：**对输入RAR和PDF文件类型的校验，确保处理对象的正确性；动态定位并读取RAR内的PDF文件，无需解压整包；利用临时文件存储PDF，调用专门库提取文本，保证环境清洁；文本结果去杂，提升数据纯净度；异常控制，面对非PDF文件给予及时响应；整体上，确保了操作的安全性、数据的准确和处理的高效率，利于后继数据加工或文本分析任务。

### 10：读取 RAR 中ppt文件内容

```rust
  pub fn read_rar_pptx_text(rar_path: &str, file_name: &str) -> UnrarResult<String> {
        assert!(fs::metadata(rar_path).is_ok(), "文件不存在,请检查路径是否正确");
        assert!(rar_path.ends_with(".rar"), "文件类型错误,请检查文件类型是否为rar文件");
    
        let mut archive = Archive::new(rar_path).open_for_processing()?;
        let mut pptx_buffer = Vec::new();
    
        loop {
            let header = archive.read_header()?;
            if header.is_none() {
                return Err(UnrarError::from(unrar::error::Code::EndArchive, unrar::error::When::Read));
            }
    
            let header = header.unwrap();
            if header.entry().filename.to_str().unwrap() == file_name {
                let (file_data, _) = header.read()?;
                pptx_buffer.extend_from_slice(&file_data[..]);
                break;
            }
    
            archive = header.skip()?;
        }
    
        let mut cursor = Cursor::new(pptx_buffer);
        let mut pptx_archive = ZipArchive::new(&mut cursor).unwrap();
    
        let mut slide_texts = String::new();
    
        for i in 0..pptx_archive.len() {
            let mut file = pptx_archive.by_index(i).unwrap();
            let file_name = file.name().to_string();
    
            if file_name.starts_with("ppt/slides/slide") && file_name.ends_with(".xml") {
                let mut xml_content = String::new();
                file.read_to_string(&mut xml_content).unwrap();
    
                let parser = EventReader::from_str(&xml_content);
                for event in parser {
                    if let Ok(XmlEvent::Characters(text)) = event {
                        slide_texts.push_str(&text);
                    }
                }
                slide_texts.push_str("\n");
            }
        }
    
        Ok(slide_texts)
    }
```

**核心功能：**该函数旨在从RAR压缩包中读取指定的PPTX文件，提取所有幻灯片的文本内容，并整合为单一字符串返回。

**特性：**设计上，先验证RAR文件的存在与格式正确性，确保操作的可靠性；然后直接定位并读取RAR内的PPTX，避免全包解压提升效率；通过解析PPTX中的XML描述，精提取每张幻灯片的文本信息；所有幻灯片内容以换行符分隔串联，便于后续处理；内置错误处理机制，确保流程稳定，面对异常能给出适当反馈。整体而言，这一功能特别适用于自动化提取文档文本信息，满足数据处理与分析需求。

## 十二：读取TAR文件内容

- [x] 列出 TAR 中的所有文件和目录
- [x] 读取 TAR 内的txt文件内容
- [x] 读取 TAR 中json文件内容
- [x] 读取 TAR 中xml文件内容
- [x] 读取 TAR 中Markdown文件内容
- [x] 读取 TAR 中excel文件内容
- [x] 读取 TAR 中pdf文件内容

### 1：列出 TAR 中的所有文件和目录

```rust
	pub fn list_tar_filenames<P: AsRef<Path>>(file_path: P) -> Result<Vec<String>> {
        assert!(fs::metadata(file_path.as_ref()).is_ok(), "文件不存在，请检查路径是否正确");
        assert!(file_path.as_ref().to_string_lossy().ends_with(".tar"), "文件类型错误，请检查文件类型是否为 tar 文件");
    
        let file = File::open(file_path)?;
        let mut archive = tar::Archive::new(BufReader::new(file));
    
        let mut file_list = Vec::new();
    
        // 遍历所有条目
        for entry in archive.entries()? {
            match entry {
                Ok(entry) => {
                    let entry_path = entry.path()?;
                    let entry_name = entry_path.to_string_lossy().to_string();
    
                    // 根据 exclude_directories 的值来决定是否排除目录
                        file_list.push(entry_name);
                }
                Err(_) => continue, // 错误处理
            }
        }
        Ok(file_list)
    }
```

**核心功能：**枚举指定.tar文件存档内的所有文件名。具体操作包括验证文件存在及格式正确，接着利用tar::Archive读取.tar存档，遍历并收集所有条目的路径名至字符串向量。

**特性：**异常的稳健处理，通过match语句确保即使遇到读取失败也能继续执行，不中断整体流程；具备高度适应性，通过泛型参数AsRef支持多种路径输入形式；利用to_string_lossy进行路径转换，保证信息完整无损；最终返回清晰的文件名列表，利于后续文件名的使用和管理，整体设计高效且实用。

### 2：读取 TAR 内的txt文件内容

```rust
	pub fn read_tar_text<P: AsRef<Path>>(tar_path: P, file_name: &str) -> Result<String> {
        assert!(fs::metadata(tar_path.as_ref()).is_ok(), "文件不存在，请检查路径是否正确");
        assert!(file_name.ends_with(".txt"), "文件类型错误，请检查文件类型是否为 txt 文件");
        let tar_file = File::open(tar_path)?;
        let mut archive = tar::Archive::new(BufReader::new(tar_file));
    
        for entry in archive.entries()? {
            let mut entry = entry?;
            let entry_path = entry.path()?;
    
            // 检查文件名是否匹配
            if entry_path.file_name().map(|name| name.to_string_lossy() == file_name).unwrap_or(false) {
                let mut contents = String::new();
                entry.read_to_string(&mut contents)?;
                return Ok(contents);
            }
        }
    
        Err(io::Error::new(io::ErrorKind::NotFound, format!("未找到指定文件: {}", file_name)))
    }
```

**核心功能：**从指定的.tar存档文件中精确读取单个.txt文件的内容。其具体操作包含验证目标.tar文件及待读取文件类型的有效性，随后通过tar::Archive接口检索与遍历存档内部结构，定位至特定的.txt文件并读取其文本内容，最终返回该文件的全部内容作为String。

**特性：**文件存在性和类型的双重检验，确保操作起点的准确性；通过递归遍历与条件过滤快速定位所需.txt文件，实现精准读取；采用read_to_string方法直接将文件内容转化为String类型，简化后处理步骤；同时，内置错误处理逻辑，针对未找到指定文件的情况返回自定义错误信息，提高函数调用的容错性与信息反馈能力，展现全面而细致的设计考量。

### 3：读取 TAR 中json文件内容

```rust
	pub fn read_tar_json<P: AsRef<Path>>(tar_path: P, file_name: &str) -> Result<Value> {
        let tar_file = File::open(tar_path)?;
        let mut archive = tar::Archive::new(BufReader::new(tar_file));
    
        for entry in archive.entries()? {
            let mut entry = entry?;
            let entry_path = entry.path()?;
    
            // 检查文件名是否匹配
            if entry_path.file_name().map(|name| name.to_string_lossy() == file_name).unwrap_or(false) {
                let reader = BufReader::new(entry);
                let json_value: Value = serde_json::from_reader(reader)?;
                return Ok(json_value);
            }
        }
    
        Err(io::Error::new(io::ErrorKind::NotFound, format!("未找到指定文件: {}", file_name)))
    }
```

**核心功能：**从指定的.tar存档中抽取特定JSON文件，并将其内容解析为Rust的数据结构Value。该功能首先打开.tar文件，创建tar::Archive实例遍历其中的所有条目。关键步骤在于对比文件名，一旦发现匹配的目标JSON文件，则立即启动解析进程，借助serde_json库将JSON文件流转化为灵活的Value对象，便于后续数据访问与操纵。

**特性：**无缝对接.tar存档与JSON文件处理，确保从文件读取到数据解析的流畅体验；采用BufReader提升读取效率，优化性能表现；利用serde_json的from_reader方法直接解析流式数据源，减少中间环节，加快处理速度；内置的错误处理逻辑，尤其是对于找不到指定文件的情况，能抛出自定义错误，增强函数的健壮性和用户友好度，展现出高水准的功能集成与细节把控能力。

### 4：读取 TAR 中xml文件内容

```rust
	pub fn read_tar_xml_text<P: AsRef<Path>>(tar_path: P, file_name: &str) -> Result<String> {
        assert!(fs::metadata(tar_path.as_ref()).is_ok(), "文件不存在，请检查路径是否正确");
        assert!(tar_path.as_ref().to_string_lossy().ends_with(".tar"), "文件类型错误，请检查文件类型是否为 tar 文件");
    
        let tar_file = File::open(tar_path)?;
        let mut archive = tar::Archive::new(BufReader::new(tar_file));
        
        // 打开指定文件
        for entry in archive.entries()? {
            let mut entry = entry?;
            let entry_path = entry.path()?;
    
            if entry_path.file_name().map(|name| name.to_string_lossy() == file_name).unwrap_or(false) {
                let mut reader = BufReader::new(entry);
                let mut content = String::new();
                reader.read_to_string(&mut content)?;
                return Ok(content);
            }
        }
    
        Err(io::Error::new(io::ErrorKind::NotFound, format!("未找到指定文件: {}", file_name)))
    }
```

**核心功能：**从指定的.tar存档中精确提取某个XML文件的全文内容。此功能首先确认.tar文件的存在及格式正确性，然后遍历存档内各项，寻找与给定名称相匹配的XML文件。找到对应文件后，读取并拼接其全部文本至单一String中，方便统一管理和进一步的XML解析或文本处理工作。

**特性：**通过assert!断言确保操作前提的准确性，避免无效或错误的文件操作；采用tar::Archive结合BufReader高效读取.tar存档内容，提升读取速率；精确定位目标XML文件，仅需关注实际需要的文件，节省资源；read_to_string方法一次性读取全部文件内容至内存，适用于小到中等大小的XML文件，简化数据处理流程；内置错误处理机制，有效反馈未找到指定文件的情形，增加程序的健壯性和用户体验，展现了功能实现上的严谨与实用性考量

### 5：读取 TAR 中Markdown文件内容

```rust
	pub fn read_tar_markdown<P: AsRef<Path>>(tar_path: P, file_name: &str) -> Result<String> {
        assert!(fs::metadata(tar_path.as_ref()).is_ok(), "文件不存在，请检查路径是否正确");
        assert!(tar_path.as_ref().to_string_lossy().ends_with(".tar"), "文件类型错误，请检查文件类型是否为 tar 文件");

        let tar_file = File::open(tar_path)?;
        let mut archive = tar::Archive::new(BufReader::new(tar_file));

        // 遍历条目，查找指定的 Markdown 文件
        for entry in archive.entries()? {
            let mut entry = entry?;
            let entry_path = entry.path()?;

            // 只匹配文件名
            if entry_path.file_name().map_or(false, |name| name == file_name) {
                let mut reader = BufReader::new(entry);
                let mut content = String::new();
                reader.read_to_string(&mut content)?;
                return Ok(content);
            }
        }

        Err(io::Error::new(io::ErrorKind::NotFound, "指定的 Markdown 文件未找到"))
    }
```

**核心功能：**从指定的.tar存档中提取一个Markdown格式文件的具体内容。该功能通过两次断言确保目标文件存在且为.tar格式，之后构建tar::Archive并遍历其中每一项。在识别到与指定文件名完全一致的条目时，即进行深度读取，将Markdown文件的全部内容载入String变量之中，便于后续的直接显示或进一步编辑。

**特性：**此函数展示了对文件先决条件的严格校验，保障了操作的合理性和安全性；使用高效的流缓冲读取方案，配合BufReader提升读取性能；对Markdown文件的精确匹配策略，确保操作针对性强，避免无关文件干扰；整合io操作与错误处理，针对未找到文件的情况给出明确响应，体现了代码的鲁棒性和良好的错误反馈机制，彰显了功能实施的高度专业性和实用性。

### 6：读取 TAR 中excel文件内容

```rust
	pub fn read_tar_excel<P: AsRef<Path>>(tar_path: P, file_name: &str) -> Result<Vec<String>> {
        assert!(fs::metadata(tar_path.as_ref()).is_ok(), "文件不存在，请检查路径是否正确");
        assert!(tar_path.as_ref().to_string_lossy().ends_with(".tar"), "文件类型错误，请检查文件类型是否为 tar 文件");

        let tar_file = File::open(tar_path)?;
        let mut archive = tar::Archive::new(BufReader::new(tar_file));

        // 打开指定文件
        for entry in archive.entries()? {
            let mut entry = entry?;
            let entry_path = entry.path()?;

            if entry_path.file_name().map(|name| name.to_string_lossy() == file_name).unwrap_or(false) {
                // 创建一个临时缓冲区来存储 Excel 文件内容
                let mut buffer = Vec::new();
                entry.read_to_end(&mut buffer)?; // 读取 Excel 文件内容到缓冲区

                // 使用 calamine 读取 Excel 文件
                let mut workbook = Xlsx::new(std::io::Cursor::new(buffer)).unwrap();

                let mut lines = Vec::new();

                // 遍历每一个工作表
                for (sheet_number, (sheet_name, sheet)) in workbook.worksheets().into_iter().enumerate() {
                    for (row_number, row) in sheet.rows().enumerate() {
                        let mut line = String::new();
                        // 处理每一行
                        for cell in row {
                            line.push_str(&cell.to_string());
                            line.push(' '); // 在单元格之间添加空格
                        }
                        lines.push(line);
                    }
                }

                return Ok(lines); // 返回读取到的行
            }
        }

        Err(io::Error::new(io::ErrorKind::NotFound, format!("未找到指定文件: {}", file_name)))
    }
```

**核心功能：**从特定的.tar存档中抽取Excel文件，并读取出其所有的表格数据。此功能始于验证目标.tar文件是否存在及其格式正确，随后创建tar::Archive实例用于遍历档案中的每个条目。发现符合指定文件名的条目后，读取整个Excel文件内容到缓存中，再利用calamine库解析这个二进制数据，逐行读取所有工作表的信息，并把每行数据合并成一个String，其间以空格分割单元格内容，最后将这些行数据汇总为Vec形式返回。

**特性：**函数确保了对目标文件的预检测，增强了操作的安全性；通过将整个Excel文件加载到内存中，配合calamine高效解析，实现了对Excel文件内部数据的深入挖掘；以逐行列的方式读取表格数据，既保留了原始表格的行布局又简化了数据格式，便于后续数据处理或展示；内置的错误处理机制能够妥善应对文件未找到的情况，提高了函数的稳定性和用户交互体验，充分展现了功能实现的专业性和完整性。

### 7：读取 TAR 中pdf文件内容

```rust
	pub fn read_tar_pdf_as_string<P: AsRef<Path>>(tar_path: P, file_name: &str) -> Result<String> {
        assert!(fs::metadata(tar_path.as_ref()).is_ok(), "文件不存在，请检查路径是否正确");
        assert!(tar_path.as_ref().to_string_lossy().ends_with(".tar"), "文件类型错误，请检查文件类型是否为 tar 文件");

        let tar_file = File::open(tar_path)?;
        let mut archive = tar::Archive::new(BufReader::new(tar_file));

        // 查找并读取指定的 PDF 文件
        for entry in archive.entries()? {
            let mut entry = entry?;
            let entry_path = entry.path()?;

            if entry_path.file_name().map(|name| name.to_string_lossy() == file_name).unwrap_or(false) {
                assert!(file_name.ends_with(".pdf"), "文件类型错误，请检查文件类型是否为 pdf 文件");

                // 创建临时文件
                let temp_dir = tempdir()?;
                let temp_file_path = temp_dir.path().join("temp.pdf");

                // 将 PDF 文件内容写入临时文件
                let mut temp_file = File::create(&temp_file_path)?;
                let mut buf = Vec::new();
                entry.read_to_end(&mut buf)?;
                temp_file.write_all(&buf)?;

                // 从临时文件中读取 PDF 内容
                let pdf_text = extract_text(temp_file_path.to_str().unwrap());
                match pdf_text {
                    Ok(text) => return Ok(text.trim_start_matches('\n').trim_end_matches('\n').to_string()),
                    Err(err) => return Err(Error::new(ErrorKind::Other, format!("无法提取 PDF 文本: {}", err))),
                }
            }
        }

        Err(Error::new(ErrorKind::NotFound, "PDF 文件不存在"))
    }
```

**核心功能：**读取位于.tar存档中的PDF文件，并将其内容转换为字符串形式。此功能首先验证.tar文件的存在性和正确格式，接着打开并解析.tar文件，寻找与指定名称匹配的PDF文件。找到后，创建一个临时文件用于存储PDF文件内容，通过读取和写入操作将PDF数据从.tar存档转移至临时文件。随后，使用特定的提取文本方法处理临时PDF文件，将PDF内容转换为字符串，并进行必要的前后空白行清理，最终返回处理后的文本字符串

**特性：**通过断言和条件检查确保操作对象的有效性和类型正确，提高数据处理的可靠性；使用临时文件作为中间媒介，避免直接在内存中处理PDF数据，既保证了数据的完整性又提升了处理效率；对PDF文本的提取过程进行了细致的错误处理，能够有效反馈提取失败的情况，增强了函数的健壮性；对最终提取的文本进行前后空白行清理，保证字符串的整洁，便于后续文本分析或展示，展现了功能实现的细致和专业。

## 十三：读取文件信息内容

- [x] 读取文件的基本属性信息
- [x] 获取文件大小，单位字节
- [x] 获取文件创建的时间
- [x] 获取上一次访问的时间
- [x] 获取文件最后修改时间
- [x] 获取文件是否为目录
- [x] 获取文件是否为普通文件
- [x] 解析文件权限位并返回一个表示权限的字符串
- [x] 获取文件权限
- [x] 获取文件扩展名

### 1：读取文件的基本属性信息

```rust
	pub fn get_file_metadata<P: AsRef<Path>>(file_path: P) -> Result<Metadata> {
        fs::metadata(file_path)
    }
```

**核心功能：**简洁明了地获取指定文件的元数据。此功能接收一个文件路径，直接调用fs::metadata方法，返回关于该文件的详细系统级信息，如权限、大小、修改时间等，封装于Metadata结构体中。

**特性：**极简的接口设计，易于理解和使用；同时依赖系统底层的强大支持，确保所获元数据的真实性和及时性，适合快速获取文件基本属性的需求。

### 2：获取文件大小，单位字节

```rust
	pub fn get_file_size<P: AsRef<Path>>(file_path: P) -> Result<u64> {
        let metadata = Self::get_file_metadata(file_path)?;
        Ok(metadata.len())
    }
```

**核心功能：**计算并返回给定文件的大小。此功能通过调用自定义的get_file_metadata方法获取文件的元数据，进而取得文件长度，即文件大小，并将其作为u64类型的数值返回。

**特性：**展现出对已有功能的良好集成，通过组合不同层次的功能模块来实现更具体的任务需求；同时也体现了代码复用的优势，减少了冗余逻辑，保持了代码的简洁和高效

### 3：获取文件创建的时间

```rust
	pub fn get_file_created_time<P: AsRef<Path>>(file_path: P) -> Result<String> {
        let metadata = Self::get_file_metadata(file_path)?;
        let created_time = metadata.created()?;
        let datetime: DateTime<Local> = created_time.into();
        Ok(datetime.format("%Y-%m-%d %H:%M:%S").to_string())
    }
```

**核心功能：**获取并格式化指定文件的创建时间。此功能通过调用get_file_metadata方法获得文件元数据，进一步获取文件的创建时间，然后将时间信息转化为本地时区的DateTime格式，并按照"年-月-日 时:分:秒"的模式格式化输出为字符串。

**特性：**灵活运用时间处理工具，将低层级的系统时间转化为可读性强的格式，方便用户理解；同时，通过链式调用增强代码连贯性，使得功能实现更加流畅和紧凑，

### 4: 获取上一次访问的时间

```rust
	pub fn get_last_accessed_time<P: AsRef<Path>>(file_path: P) -> Result<String> {
        let metadata = Self::get_file_metadata(file_path)?;
        let accessed_time = metadata.accessed()?;
        let datetime: DateTime<Local> = accessed_time.into();
        Ok(datetime.format("%Y-%m-%d %H:%M:%S").to_string())
    }
```

**核心功能：**提取并格式化文件的最后一次访问时间。通过调用get_file_metadata方法获取文件的基础元数据，特别聚焦于文件的最近一次访问记录，将其转化为DateTime格式，并按照统一的"年-月-日 时:分:秒"样式呈现为字符串。

**特性：**精准定位文件活动状态中的访问历史，结合标准时间格式输出提升信息的直观度与规范性；同时，借助Rust强大的错误处理机制及类型系统，确保每一环节的稳健执行，适用于监控文件动态或审计文件使用情况的场景。

### 5：获取文件最后修改时间

```rust
	pub fn get_last_modified<P: AsRef<Path>>(file_path: P) -> Result<String> {
        let metadata = Self::get_file_metadata(file_path)?;
        let modified_time = metadata.modified()?;
        let datetime: DateTime<Local> = modified_time.into();
        Ok(datetime.format("%Y-%m-%d %H:%M:%S").to_string())
    }
```

**核心功能：**精确展现为获取文件最后修改时间戳并格式化输出。这一功能通过调用get_file_metadata方法来检索文件元数据，特地抓取文件的最后修改时刻，随后将这个时间信息转换成为本地时区下易读的DateTime格式，并以"年-月-日 时:分:秒"的形式生成字符串。

**特性：**它着重于捕捉文件最新的变动状态，采用统一的时间格式提升显示效果的专业性；同时，利用Rust语言严谨的错误管理策略，确保每一步骤的稳健运行

### 6：获取文件是否为目录

```rust
	pub fn is_directory<P: AsRef<Path>>(file_path: P) -> Result<bool> {
        let metadata = Self::get_file_metadata(file_path)?;
        Ok(metadata.is_dir())
    }
```

**核心功能：**判断给定路径是否指向一个目录。通过调用get_file_metadata方法获取指定路径的元数据，然后直接利用元数据的is_dir方法来确定该路径是否对应一个目录，最终返回布尔值结果。

**特性：**高效判断路径类型，代码简洁且直击需求核心；同时，利用Rust的Result类型来处理可能发生的错误

### 7：获取文件是否为普通文件

```rust
	pub fn is_regular_file<P: AsRef<Path>>(file_path: P) -> Result<bool> {
        let metadata = Self::get_file_metadata(file_path)?;
        Ok(metadata.is_file())
    }
```

**核心功能：**判定指定路径是否为常规文件。通过调用get_file_metadata方法从目标路径收集元数据，进而检查其是否满足普通文件的特征，最终输出相应的布尔判断结果

**特性：**凸显了对文件类型的有效甄别能力，代码设计精炼，能够迅速反馈文件性质；同时，运用Rust的Result机制妥善处理潜在异常，保证了函数操作的安全性和稳定性，非常适合应用于文件系统导航或资源分类等流程中。

### 8：解析文件权限位并返回一个表示权限的字符串

```rust
	pub fn parse_permissions(attrs: u32) -> String {
        let owner_read = if attrs & 0o400 != 0 { "r" } else { "-" };  // 0o 表示后面的数是8进制表示
        let owner_write = if attrs & 0o200 != 0 { "w" } else { "-" };
        let owner_exec = if attrs & 0o100 != 0 { "x" } else { "-" };

        let group_read = if attrs & 0o040 != 0 { "r" } else { "-" };
        let group_write = if attrs & 0o020 != 0 { "w" } else { "-" };
        let group_exec = if attrs & 0o010 != 0 { "x" } else { "-" };

        let other_read = if attrs & 0o004 != 0 { "r" } else { "-" };
        let other_write = if attrs & 0o002 != 0 { "w" } else { "-" };
        let other_exec = if attrs & 0o001 != 0 { "x" } else { "-" };

        format!(
            "{}{}{}-{}{}{}-{}{}{}",
            owner_read, owner_write, owner_exec,
            group_read, group_write, group_exec,
            other_read, other_write, other_exec
        )
    }
```

**核心功能：**对整数形式的权限字段进行分析，转换为人类可读的权限字符串。代码遍历文件所有者、所属组和其他用户三个层面的读、写、执行权限，通过位运算检查各个权限位是否设置，再映射到字符'r'、'w'、'x'或'-'，分别代表具有相应权限或无权

**特性：**精细解读二进制权限信息的能力上，巧妙利用位掩码和条件逻辑，将复杂的权限状态转化为一目了然的文本描述，适用于文件系统权限展示或配置解释的应用环境，增强了权限管理的可视性和易懂性。

### 9：获取文件权限

```rust
	pub fn get_file_permission<P: AsRef<Path>>(file_path: P) -> Result<String> {
        let metadata = Self::get_file_metadata(file_path)?;
        let permissions = metadata.permissions();
        match permissions.readonly() {
            true => Ok(String::from("r--")), // 这是是简化了的，windows获得文件执行权限很复杂
            false => Ok(String::from("rw-")),
        }
    }
```

**核心功能：**查询并简化表示文件的读写权限。通过获取文件的元数据，进一步提取文件的权限信息，主要关注文件的只读属性。依据文件是否设置为只读，构造并返回一个描述基本读写权限的字符串："r--"表征只读，而"rw-"则指示可读可写

**特性：**代码专注于提炼关键权限状态，提供了快速查看文件访问级别的手段；同时，采用 Rust 的 error handling 来增强函数健壮性

### 10：获取文件扩展名

```rust
	pub fn get_file_extension<P: AsRef<Path>>(file_path: P) -> String {
        file_path.as_ref().extension().and_then(|ext| ext.to_str()).unwrap_or("unknown").to_string()
    }
```

**核心功能：**获取文件路径中的扩展名部分。代码通过as_ref方法转换单给定路径，接着调用extension方法尝试提取文件后缀名，再借助to_str将其转换为有效的UTF-8字符串，最后以字符串形式返回文件扩展名，如果路径中没有扩展名，则默认返回"unknown"作为占位符。

**特性：**代码实现了对文件后缀的灵活捕获，兼容不同类型的文件命名规范；同时，运用Option链式调用来处理可能的None情况，避免panic，保证了函数的稳定输出与广泛适用性，在文件类型识别或过滤应用场景中表现出色。